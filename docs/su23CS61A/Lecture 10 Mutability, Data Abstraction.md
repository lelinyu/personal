# Lecture 10 Mutability, Data Abstraction

1. Questions
    1. Constructor vs selector vs attributes, object oriented programming?
    2. How does python know what to do when minusing two instances of date without the method?
    3. For the dictionary example, where does values() come from?
2. Data Abstraction
    1. Compound values combine other values together
    2. Lets us manipulate compound values as units
    3. Rational Numbers
        1. Exact representation of fractions
        2. A pair of integers
        3. Assume we can compose and decompose rational numbers
        4. Constructor
            1. rational(n,d)
        5. Selectors
            1. numer(x)
            2. denom(x)
3. Representing Rational Numbers
    1. Construct a list
    2. numer and denom can select item from list
    3. Reducing to Lowest Terms
4. Abstraction Barriers
    1. Use rational numbers to perform computation
    2. Create rationals or implement rational operations
    3. Implement selectors and constructor for rationals
    4. Implementation of lists
        1. ^ all the code above is separated by abstraction barriers
        2. Don’t need to know how code is implemented
    5. Violating Abstraction Barriers
        1. We just assume that our rationals are represented by lists
        2. Don’t do this, instead use the constructors and selectors
5. Data Representations
    1. What are data?
        1. need to make sure constructor and selector
    2. Rationals Implemented as Functions
        1. Making a function that represents a rational number
6. Mutability
    1. Objects
        1. behaves like what it represents
        2. represents information
        3. consist of data and behavior, bundled to create abstractions
        4. Object-oriented programming
        5. All objects have attributes
            1. A lot of data manipulation happens though object methods
7. Example: Strings
    1. ASCII for Strings
    2. Unicode Standard
        1. Abstraction that allows us to work with text
        2. importing unicode
            
            ```python
            import unicodedata import lookup, name
            
            name('A')
            >>> 'LATIN CAPITAL LETTER A'
            
            lookup('SNOWMAN')
            >>> (Snowman Emoji that I can't type right now)
            ```
            
    3. Lists
        1. .remove()
            1. search the list and remove that value without returning
        2. .pop()
            1. removing the value at index, but it does return what it took away
        3. .extend
            1. took the values inside a list and puts it in the list
        4. .append
            1. takes a value (not a list) and adds it to the end of the list
        5. original_suits and suits point to the same object
    4. Some objects can change
        1. the same object can change in value throughout the course of computation
        2. All names that refer t the same object are affected by a mutation
        3. Only objects of mutable types can change
    5. Mutation can happen within a function call
        1. A function can change the value of any object in its scope
        2. Doesn’t necessarily need to be passed in as an argument
8. Tuples
    1. Create by using parentheses (high recommended)
    2. Immutable
        1. convert a list into a tuple to make it immutable
        2. Value of an expression can change because of
            1. name change
            2. object mutation
        3. An immutable sequence may still change if it contains a mutable value as an element
            1. We can change mutable values inside tuples
                1. Change the value of the list
    3. Adding tuples concatenate them
9. Mutation
    1. Sameness and Changes
        1. A list is the “same” list even if we change its values
    2. Identity Operations
        1. Identity uses the “is” keyword
            1. Evaluates if they are the same object
        2. Equality uses “==”
            1. Evaluates if the values are the same
        3. Identical objects are always equal values
    3. Mutable Default Arguments are Dangerous
        1. A default argument value is part of a function value, not generated by a call
        2. default argument s is stored with the object
            1. s is the same list even between different calls
10. Mutable Functions
    1. Modeling a bank account that has a balance of $100
    2. Stored the money in a mutable list in the global frame
        1. Name bound outside of withdraw def