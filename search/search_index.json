{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bryan's Website!","text":"<p>Hi! Welcome to my website where you can find more information about me and some of the work that I've been doing.</p>"},{"location":"#about-me","title":"About me","text":"<ul> <li> UCLA Class of 2028</li> <li> Computer Science major</li> <li> Interests: AI/ML and Data Science</li> <li> Hobbies: Skiing and Volleyball</li> </ul>"},{"location":"#my-resume","title":"My Resume","text":"<p>Click here to view my Resume</p>"},{"location":"Past%20Notes/","title":"Past Notes","text":"<p>Here's some of the past notes that I've taken during my time at:</p> <p>California Crosspoint Academy</p> <p>2017-2024 Middle School and High School Classes</p> <p>UC Berkeley Summer Sessions</p> <p>2022 and 2023 Summer Courses DATA8 and CS61A</p> <p>UCLA</p> <p>2024-2028 Courses as a Computer Science Major</p>"},{"location":"su23CS61A/Lecture%201%20Welcome/","title":"Lecture 1 Welcome","text":"<ul> <li>Questions<ul> <li>Is steps 2 and 1 swapped?</li> <li>1.1.4 functions are objects, objects are functions, and interpreters are instances of both</li> </ul> </li> <li>Computer Science Overview<ul> <li>What problems can be solved</li> <li>What techniques lead to effective solutions</li> </ul> </li> <li>CS61a overview<ul> <li>managing complexity<ul> <li>abstraction</li> </ul> </li> <li>intro to programming<ul> <li>how computers interpret programming languages</li> </ul> </li> </ul> </li> <li>Course Format<ul> <li>Lecture<ul> <li>Prerecorded lectures by DeNero</li> </ul> </li> <li>Discussion (Tu/Th)<ul> <li>Concepts more like an exam</li> </ul> </li> <li>Lab (M/W)<ul> <li>Meant to be collaborative</li> <li>More introductory to material</li> <li>Need attendance + submission</li> <li>2 days to complete each lab</li> </ul> </li> <li>Office hours<ul> <li>Held everyday</li> </ul> </li> <li>Tutoring (optional)<ul> <li>1 hour twice a week</li> </ul> </li> <li>Textbook</li> <li>Homework<ul> <li>Often more difficult problems</li> <li>Released Monday, due Thursday</li> </ul> </li> <li>Projects<ul> <li>1.5 weeks to complete</li> <li>pairs of 2 projects</li> </ul> </li> <li>Exams<ul> <li>Midterm - 64 points</li> <li>Final - 96 points</li> </ul> </li> </ul> </li> <li>Expressions<ul> <li>expression - describes a computation and evaluates to a value</li> <li>Python follows order of operations</li> <li>What is a computer program?<ul> <li>computer programs manipulate values</li> <li>expressions in programs evaluate to values</li> </ul> </li> <li>Call Expressions<ul> <li>add (2, 3)</li> <li>add - operator</li> <li>operand - 2 and 3</li> <li>Order<ul> <li>Evaluate the operator</li> <li>Evaluate the operands from left to right</li> <li>Apply the operator to the evaluated operands</li> </ul> </li> <li>Nest Call Expression<ul> <li>add(add,6,mul(4,6)), mul(3,5))</li> <li> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"su23CS61A/Lecture%201%20Welcome/#humans-evaluate-inside-out","title":"Humans evaluate inside out","text":""},{"location":"su23CS61A/Lecture%2010%20Mutability%2C%20Data%20Abstraction/","title":"Lecture 10 Mutability, Data Abstraction","text":"<ol> <li>Questions<ol> <li>Constructor vs selector vs attributes, object oriented programming?</li> <li>How does python know what to do when minusing two instances of date without the method?</li> <li>For the dictionary example, where does values() come from?</li> </ol> </li> <li>Data Abstraction<ol> <li>Compound values combine other values together</li> <li>Lets us manipulate compound values as units</li> <li>Rational Numbers<ol> <li>Exact representation of fractions</li> <li>A pair of integers</li> <li>Assume we can compose and decompose rational numbers</li> <li>Constructor<ol> <li>rational(n,d)</li> </ol> </li> <li>Selectors<ol> <li>numer(x)</li> <li>denom(x)</li> </ol> </li> </ol> </li> </ol> </li> <li>Representing Rational Numbers<ol> <li>Construct a list</li> <li>numer and denom can select item from list</li> <li>Reducing to Lowest Terms</li> </ol> </li> <li>Abstraction Barriers<ol> <li>Use rational numbers to perform computation</li> <li>Create rationals or implement rational operations</li> <li>Implement selectors and constructor for rationals</li> <li>Implementation of lists<ol> <li>^ all the code above is separated by abstraction barriers</li> <li>Don\u2019t need to know how code is implemented</li> </ol> </li> <li>Violating Abstraction Barriers<ol> <li>We just assume that our rationals are represented by lists</li> <li>Don\u2019t do this, instead use the constructors and selectors</li> </ol> </li> </ol> </li> <li>Data Representations<ol> <li>What are data?<ol> <li>need to make sure constructor and selector</li> </ol> </li> <li>Rationals Implemented as Functions<ol> <li>Making a function that represents a rational number</li> </ol> </li> </ol> </li> <li>Mutability<ol> <li>Objects<ol> <li>behaves like what it represents</li> <li>represents information</li> <li>consist of data and behavior, bundled to create abstractions</li> <li>Object-oriented programming</li> <li>All objects have attributes<ol> <li>A lot of data manipulation happens though object methods</li> </ol> </li> </ol> </li> </ol> </li> <li> <p>Example: Strings</p> <ol> <li>ASCII for Strings</li> <li> <p>Unicode Standard</p> <ol> <li>Abstraction that allows us to work with text</li> <li> <p>importing unicode</p> <pre><code>import unicodedata import lookup, name\n\nname('A')\n&gt;&gt;&gt; 'LATIN CAPITAL LETTER A'\n\nlookup('SNOWMAN')\n&gt;&gt;&gt; (Snowman Emoji that I can't type right now)\n</code></pre> </li> </ol> </li> <li> <p>Lists</p> <ol> <li>.remove()<ol> <li>search the list and remove that value without returning</li> </ol> </li> <li>.pop()<ol> <li>removing the value at index, but it does return what it took away</li> </ol> </li> <li>.extend<ol> <li>took the values inside a list and puts it in the list</li> </ol> </li> <li>.append<ol> <li>takes a value (not a list) and adds it to the end of the list</li> </ol> </li> <li>original_suits and suits point to the same object</li> </ol> </li> <li>Some objects can change<ol> <li>the same object can change in value throughout the course of computation</li> <li>All names that refer t the same object are affected by a mutation</li> <li>Only objects of mutable types can change</li> </ol> </li> <li>Mutation can happen within a function call<ol> <li>A function can change the value of any object in its scope</li> <li>Doesn\u2019t necessarily need to be passed in as an argument</li> </ol> </li> <li>Tuples</li> <li>Create by using parentheses (high recommended)</li> <li>Immutable<ol> <li>convert a list into a tuple to make it immutable</li> <li>Value of an expression can change because of<ol> <li>name change</li> <li>object mutation</li> </ol> </li> <li>An immutable sequence may still change if it contains a mutable value as an element<ol> <li>We can change mutable values inside tuples<ol> <li>Change the value of the list</li> </ol> </li> </ol> </li> </ol> </li> <li>Adding tuples concatenate them</li> <li>Mutation</li> <li>Sameness and Changes<ol> <li>A list is the \u201csame\u201d list even if we change its values</li> </ol> </li> <li>Identity Operations<ol> <li>Identity uses the \u201cis\u201d keyword<ol> <li>Evaluates if they are the same object</li> </ol> </li> <li>Equality uses \u201c==\u201d<ol> <li>Evaluates if the values are the same</li> </ol> </li> <li>Identical objects are always equal values</li> </ol> </li> <li>Mutable Default Arguments are Dangerous<ol> <li>A default argument value is part of a function value, not generated by a call</li> <li>default argument s is stored with the object<ol> <li>s is the same list even between different calls</li> </ol> </li> </ol> </li> <li>Mutable Functions</li> <li>Modeling a bank account that has a balance of $100</li> <li>Stored the money in a mutable list in the global frame<ol> <li>Name bound outside of withdraw def</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2011%20ADT%20Trees/","title":"Lecture 11 ADT Trees","text":"<ol> <li>Questions<ol> <li>Why doesn\u2019t increment and double do infinite recursion if there is no base case? 11:40am</li> </ol> </li> <li>Trees<ol> <li>Recursive description<ol> <li>A tree has a root label and a list of branches</li> <li>Each branch is a tree</li> <li>Tree with zero branches is a leaf (no lines going downward)</li> </ol> </li> <li>Relative description (family trees)<ol> <li>Each location in a tree is called a node (a circle)</li> <li>Each node has a label that can be any value</li> <li>One node can be the parent/child of another</li> <li>The top node is the root node</li> </ol> </li> <li>Path<ol> <li>series of node and edges connecting the tree</li> </ol> </li> <li>Implementing the Tree Abstraction<ol> <li>a tree has a root label and a list of branches</li> <li>Each branch is a tree<ol> <li>Branches must be trees</li> <li>Use tree constructor when creating branches</li> </ol> </li> <li>Functions<ol> <li>double function<ol> <li>applying a function to all the values in the tree</li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> <li>Tree Processing<ol> <li>Creating Trees<ol> <li>Putting a recursive function into a list comprehension</li> </ol> </li> <li>tree Processing Uses Recursion<ol> <li>List of leaf labels for each branch<ol> <li>still gives back a list of leaves</li> </ol> </li> </ol> </li> </ol> </li> <li>Tree Representation<ol> <li>can use print_tree</li> <li>draw() \u2190 at code.cs61a.org</li> </ol> </li> <li>Example: Counting Paths</li> <li>Memoization<ol> <li>Recursive Computation of the Fibonacci Sequence<ol> <li>A lot of the recursion is repeated</li> <li>We can store recursion values to be used later<ol> <li>Cache \u2192 dictionary that stores our values</li> <li>keys are the function calls</li> <li>store results in dictionary 3.</li> </ol> </li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2012%20Iterators%20and%20Generators/","title":"Lecture 12 Iterators and Generators","text":"<ol> <li>Questions<ol> <li>why is map considered easily </li> <li>how does the countdown function keep track of k</li> <li>Does yield skip to the next one?</li> </ol> </li> <li>Iterables<ol> <li>objects (or data) that can be iterated over</li> <li>contains some elements in some order that can be kept track of by going from one element to the next; looped over</li> <li>Can i use it in a for loop or list comprehension?<ol> <li>if yes, then it is an iterable</li> </ol> </li> <li>Examples<ol> <li>list</li> <li>string</li> <li>dictionary</li> <li>range</li> <li>tuple</li> <li>Iterators</li> </ol> </li> </ol> </li> <li>Iterators<ol> <li>Container can provide an iterator that provides access to its elements in order</li> <li>iter(iterable)<ol> <li>return an iterator over the elements of an iterable value</li> </ol> </li> <li>next(iterator)<ol> <li>return the next element in an iterator</li> </ol> </li> <li>If we start a new iterator, it starts from the beginning</li> <li>We error if we use iterable when there are no more elements</li> <li>Can pass iterator into a list<ol> <li>interpreter returns the rest of the iterable\u2019s values</li> </ol> </li> <li>Arrow pointer is stored as an index<ol> <li>if you get rid of elements, then the new index value is evaluated</li> </ol> </li> <li>Iterators are like bookmarks<ol> <li>An iterator is an iterable</li> </ol> </li> </ol> </li> <li>Dictionary Iteration<ol> <li>View of a Dictionary<ol> <li>iterator returned from iter and can be passed to next;</li> <li>all iterators are mutable</li> </ol> </li> <li>A dictionary, its keys, its values, and its items are all iterable values<ol> <li>The order of items in a dictionary is the order in which they were added (Python 3.6+)</li> </ol> </li> </ol> </li> <li>For Statements<ol> <li>Can put iterators in a for loop<ol> <li>will complete the iterator in a normal for loop</li> </ol> </li> </ol> </li> <li>Built-in Iterator Functions<ol> <li>Many results are computed lazily<ol> <li>Only computed when needed</li> </ol> </li> <li>Examples<ol> <li>map(func, iterable)<ol> <li>iterate over func(x) for x in iterable</li> </ol> </li> <li>filter(func, iterable)<ol> <li>iterate over x in iterable if func(x)</li> </ol> </li> <li>zip(first_iter, second_iter):</li> <li>reversed(sequence)<ol> <li>iterate over x in a sequence in reverse order</li> </ol> </li> </ol> </li> <li>To view the contents of an iterator, place the result elements into a container<ol> <li>list(iterable)</li> <li>tuple(iterable)</li> <li>sorted(iterable)</li> </ol> </li> <li>Map returns an iterator<ol> <li>only computers when calling next on it</li> </ol> </li> <li>Reversed doesnt auto compute reverse of t, only when you ask it to</li> </ol> </li> <li>The Zip Function<ol> <li>Returns an iterator over co-indexed tuples</li> <li>Zip skips extra numbers</li> </ol> </li> <li>Using Iterators<ol> <li>Reasons for Using Iterators<ol> <li>Code that processes an iterator (via next) or iterable (via for or iter) makes few assumptions about the data itself</li> <li>useful for ensuring that each element of a sequence is processed only once</li> <li>limits the operations that can be performed on a sequence by only calling next</li> </ol> </li> </ol> </li> <li>Generator<ol> <li>special type of iterator</li> <li>Generators and Generator Functions<ol> <li>can yield multiple values</li> <li>yield is like a return statement, but you can yield multiple values</li> <li>A generator function can yield multiple times<ol> <li>generator is an iterator created automatically by calling a generator function</li> <li>generator functions when called, returns a generator that iterates over its yields</li> </ol> </li> </ol> </li> <li>All generators are iterators<ol> <li>iterates through its yield statements</li> </ol> </li> <li>Generator Functions can Yield from Iterables<ol> <li>yield from statement yields all values from an iterator or iterable</li> <li>basically a for loop that yields all the values from a generator</li> </ol> </li> <li>You can yield all values from recursive call with yield from</li> <li>Yielding Partitions<ol> <li>3</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2013%20Efficiency/","title":"Lecture 13 Efficiency","text":"<ol> <li>Questions</li> <li>Measuring efficiency<ol> <li>How much resource consumption a computation task takes</li> <li>We are concerned with time and space efficiency</li> <li>Time efficiency<ol> <li>how long to wait</li> </ol> </li> <li>Memory Efficiency<ol> <li>how much memory running your application takes</li> </ol> </li> </ol> </li> <li>Orders of Growth<ol> <li>Prepend<ol> <li>Adding something to the end of a list</li> </ol> </li> </ol> </li> <li>Exponentiation<ol> <li>We don\u2019t really care about the values, more that the computation is linear</li> <li>Logarithmic exponentiation</li> <li>Quadratic Time</li> <li>Exponential Time</li> </ol> </li> <li>Common Orders of Growth<ol> <li>Exponential growth<ol> <li>fibonaci</li> </ol> </li> <li>Quadratic<ol> <li>overlap</li> </ol> </li> <li>Linear<ol> <li>slow exp</li> </ol> </li> <li>Logarithmic growth<ol> <li>exp_fast</li> </ol> </li> <li>Constant growth<ol> <li>increasing n doesn\u2019t affect time</li> </ol> </li> </ol> </li> <li>Order of Growth Notation<ol> <li>Big Theta and Big O Notation for Orders of Growth<ol> <li>BigO represents the worst case<ol> <li>O(b^n)</li> <li>O(n^2)</li> <li>O(log n)</li> </ol> </li> <li>Big Theta is average case</li> </ol> </li> </ol> </li> <li>Space Usage<ol> <li>Space and Environments<ol> <li>At any moment, there is a set of active environments</li> <li>Values and frame in active environments consume memory<ol> <li>We can close frames once we know their return value</li> </ol> </li> <li>Space consumption<ol> <li>The longest path (depth) of the tree of fib</li> </ol> </li> </ol> </li> <li>Generators are lazy<ol> <li>They save space when we use them because they don\u2019t need to compute everything 3.</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2015%20Objects/","title":"Lecture 15 Objects","text":"<ol> <li>Questions</li> <li>Object-Oriented Programming<ol> <li>A method for organizing programs<ol> <li>Data Abstraction</li> <li>Bundling together info and related behavior</li> </ol> </li> <li>Computation using distributed state<ol> <li>Each object has its own local state</li> <li>Each object also knows how to manage its own local state, based on method calls</li> <li>Method calls are messages passed between objects</li> <li>Different types may relate to each other</li> </ol> </li> </ol> </li> <li>Classes<ol> <li>A class describes the general behavior of its instances</li> </ol> </li> <li>Class vs Objects<ol> <li>A class combines and abstracts data and functions</li> <li>An object is an instantiation of a class</li> </ol> </li> <li> <p>Class Statements</p> <ol> <li>The Class Statement<ol> <li>Note: By convention, class names start with a capital letter</li> <li>Class statement creates a new class and bines that class to  in the first frame of the current environment <li>Assignment and def statements in  create attributes of the class <pre><code>class &lt;name&gt;:\n    &lt;suite&gt;\n    color = 'red'\n    windows = 2\n</code></pre> <ol> <li>When a class is called<ol> <li>A new instance of that class is created:</li> <li>The init method of the class is called with the new object as its first argument (named self), along with any additional arguments provided in the call expression</li> <li>What is self?<ol> <li>references the object that you are trying to create</li> <li>technically binds self to what you bind the object to</li> </ol> </li> </ol> </li> <li>Object identity<ol> <li>Every object that is an instance of a user-defined class has a unique identity</li> <li>Identity operators \u201cis\u2019 and \u201cis not\u201d test if two expressions evaluate to the same object</li> </ol> </li> <li>Methods</li> <li>Methods<ol> <li>Functions defined in the suite of a class statement</li> <li>self should always be bound to an instance of the Account class<ol> <li>We need to know which account to apply the method on</li> </ol> </li> </ol> </li> <li>Invoking Methods<ol> <li>All invoked methods have access to the object via the self parameter, and so they can all access and manipulate the object\u2019s state</li> <li>Dot notation automatically supplies the first argument to a method<ol> <li>tom_account.deposit(100)</li> <li>^ \u201ctom_account\u201d technically being passed into self</li> </ol> </li> </ol> </li> <li>Dot expressions<ol> <li>Objects receive messages via dot notation</li> <li>dot notation accesses attributes of the instance or its class</li> <li>.<ol> <li> can be any valid Python expression <li> is probably more simple <li>Evaluates to the value of the attribute looked up by  in the object that is the value of the  <li>Attributes</li> <li>Accessing Attributes<ol> <li>Using getattr, we can look up an attribute using a string</li> <li>getattr(tom_account, \u2018balance\u2019)<ol> <li>passing in the object and the attribute you want to look up</li> </ol> </li> <li>hasattr, searches if attribute exists</li> <li>Looking up an attribute name in an object may return<ol> <li>one of its instance attributes</li> <li>one of the class attributes</li> </ol> </li> </ol> </li> <li>Methods and Functions<ol> <li>Python distinguishes between:<ol> <li>Functions<ol> <li>Function: all arguments within parentheses</li> </ol> </li> <li>Bound methods, which couple together a function and the object on which that method will be invoked<ol> <li>Method: One object in the front and the rest of the args afte</li> </ol> </li> <li>Object + Function = Bound Method</li> </ol> </li> <li>Looking up Attributes by name<ol> <li>To evaluate a dot expression:<ol> <li>Evaluate the  to the left of the dot, which yields the object of the dot expression <li> is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned <li>It not,  is looked up in the class, which yields a class attribute value <li>That value is returned unless it is a function, in which case a bound method is returned instead</li> <li>Class Attributes<ol> <li>\u201cshared\u2019 across all instances of a class because they are attributes of the class, not he instance</li> <li>By convention, class attributes defined before the constructor</li> </ol> </li> <li>Example: Bouncing Balls</li> <li>Ball Instance<ol> <li>Allocate memory for a Ball object</li> <li>Initilialize the Ball object with values</li> <li>Return the Ball object</li> </ol> </li> <li>Ball Class<ol> <li>Making multiple Ball instances</li> </ol> </li> <li>Multi-class programs</li> <li>Usually need more than one class of objects in our program to model its complexity</li> <li>Face, eye, nose<ol> <li>All different classes</li> </ol> </li>"},{"location":"su23CS61A/Lecture%2016%20Inheritance%20and%20String%20Representation/","title":"Lecture 16 Inheritance and String Representation","text":"<ol> <li>Questions<ol> <li>Repr will print quotes</li> <li>Calling on interpreter will not<ol> <li>calling interpreter on obj equvialent to</li> <li>obj = print(repr(obj))</li> </ol> </li> <li>str(obj) = obj.str()<ol> <li>when using str, use the class of the object that is being used</li> </ol> </li> </ol> </li> <li>Review<ol> <li>Attributes<ol> <li>all objects have attributes</li> <li>name-value pairs</li> <li>Classes are objects too, so they have attributes</li> <li>Instance attribute: attribute of an instance</li> <li>Class attribute: attribute of the class of an instance</li> </ol> </li> <li>Looking up attributes by name<ol> <li>. <li>Class attributes<ol> <li>\u201cshared\u201d across all instances of a class</li> </ol> </li> <li>Attribute Assignment<ol> <li>If the object is an instance, then assignment sets an instance attribute</li> <li>If the object is a class, then assignment sets a class attribute</li> </ol> </li> <li>Inheritance<ol> <li>relating classes together</li> <li>Specialized class may have the same attributes as the general class, along with some special case behavior</li> <li>Example: Checking Account<ol> <li>Two options for withdrawing</li> <li>super()<ol> <li>creates a temporary object of the parent account</li> </ol> </li> </ol> </li> <li>Looking up attribute names on classes<ol> <li>Base class attributes aren\u2019t copied into subclasses</li> <li>Looking up a name in a class<ol> <li>If it names an attribute in the class, return the attribute value</li> <li>Otherwise, look up the name in the base class, if there is one</li> </ol> </li> <li>Modifying the class attribute in the base class, affects the child class</li> </ol> </li> <li>Class Relationships<ol> <li>You can make a child class of a child class</li> </ol> </li> <li>Class Hierarchy<ol> <li>Account<ol> <li>Checking Account, Savings Account<ol> <li>SuperSaverAccount</li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> <li>Object-Oriented Design<ol> <li>Don\u2019t need to repeat ourselves if we just use existing implementations</li> <li>Inheritance and Composition<ol> <li>Inheritance is best for representing is-a relationships<ol> <li>A checking account is a specific type of account</li> <li>Checking Account inherits from Account</li> </ol> </li> </ol> </li> </ol> </li> <li>Multiple Inheritance<ol> <li>Can inherit multiple classes</li> <li>Methods come from the different parents of the As Seen on TV Account</li> <li>If methods overlap<ol> <li>Look left to right to see who has precedence</li> <li>Left has priority</li> </ol> </li> </ol> </li> <li>Representation<ol> <li>String Representations<ol> <li>An object value should behave like the kind of data it is meant to represent</li> <li>In python all objects produce two string representations<ol> <li>The str is legible to humans</li> <li>the repr is legible to the Python Interpreter</li> </ol> </li> </ol> </li> <li>repr String for an Object<ol> <li>repr(object) \u2192 string</li> <li>It returns the string to return the object</li> <li>The result of calling repr on a value is what Python prints in an interactive session</li> <li>Some objects do not have a simple Python-readable string<ol> <li> <p>repr(min)</p> </li> <li>\u2018\u2019 <li>str String representation for an Object<ol> <li>Human interpretable strings are useful as well</li> <li>str gives a more human readable version</li> <li>Result of calling str on the value of an expression is what Python prints using the \u201cprint\u201d function</li> </ol> </li> <pre><code>&gt;&gt;&gt; repr(half)\n'Fraction(1,2)'\n&gt;&gt;&gt;str(half)\n'1/2'\n</code></pre> <ol> <li> <p>F-Strings</p> <ol> <li>String Interpolation in Python<ol> <li>evaluating a string literal that contains expresssions</li> <li>Putting brackets around our string to display the value</li> </ol> </li> <li>Result of evaluating an f-string literatal contains the str value of each subexpression</li> </ol> <pre><code>&gt;&gt;&gt; f\"add 1 + 2 = {1 + 2}\"\n'add 1 + 2 = 3'\n</code></pre> </li> </ol> <pre><code>Making our own str and repr\n\ndef __str__(self):\n    return f\"Holder: {self.holder}\\nBalance: {self.balance}\"\n\ndef __repr__(self):\n    return f\"Account('{self.holder}')\"\n\n#print result has the actual result\n#str(a) is the actual string it self, so the \\n is not honored\n</code></pre>"},{"location":"su23CS61A/Lecture%2017%20Trees%20%28class%29/","title":"Lecture 17 Trees (class)","text":"<ol> <li>Questions</li> <li>Trees<ol> <li>Tree class definition<ol> <li>self.branches is always a list of Tree objects</li> <li>Trees are recursive by nature</li> </ol> </li> <li>Tree terminology<ol> <li>If t is an instance of a tree</li> <li>Variable t is pointing at the root of our tree</li> <li>Individual tree objects contained within it known as nodes</li> </ol> </li> <li>ADT Trees vs OOP Tree<ol> <li>Know the differences</li> <li>OOP Tree is Capital letters for a class</li> <li>ADT Tree is lowercase for a method</li> </ol> </li> <li>Accessing branches attribute<ol> <li>Branches are a list of trees</li> <li>t.branches[0] \u2190 to get the first branch</li> <li>t.branches[1].branches[2] \u2190 Nested branches</li> </ol> </li> <li>What is t.branches?<ol> <li>It is a list of tree objects, not Tree objects themselves</li> </ol> </li> <li>Tree processing<ol> <li>Each Tree has<ol> <li>A label</li> <li>0 or more branches, which are themselves Trees</li> </ol> </li> <li>Most of our algorithms to process trees are going to be recursive</li> </ol> </li> </ol> </li> <li>Examples</li> </ol> <p>Count Trees</p> <pre><code>def count_leaves(t):\n    if t.is_leaf():\n        return 1\n    else:\n        sum = 0 \n        for b in t.branches:\n            sum += count_leaves(b)\n        return sum\n    #also able to do one line solution\n    #return sum([counter_leaves(b) for b in t.branches])\n</code></pre> <p>List leaves</p> <pre><code>#Returns a list of leaf labels of T\n\ndef list_leaves(t):\n    if t.is_leaf():\n        return [t.label]\n    else:\n        counter = []\n        for b in t.branches:\n            counter += list_leaves(b)\n        return counter\n        #two liner\n        #list_of_lists = [list_leaves(b) for b in t.branches]\n        #return sum(list_of_lists, start=[])\n</code></pre> <p>Count Paths</p> <pre><code>def count_paths(t, total):\n    counter = 0\n    if total == t.label:\n        counter += 1\n    for b in t.branches:\n        counter += count_paths(b, total-t.label)\n    return counter\n\n#Two liner\n# found = int(t.label == total)\n# return sum([count_paths(b, total-t.label) for b in t.branches]) + found\n</code></pre> <ol> <li>String Representation</li> </ol> <pre><code>#prints the nodes of the tree with depth based indent\ndef print_tree(t):\n    def helper(t, indent):\n        print (indent * \" \" + str(t.label))\n        for b in t.branches:\n            helper(b, indent + 2) #2 is an arbitrary number, just the amt of indent we want\n    helper(t, 0)\n\n#If you need to carry information across recursive calls, use a helper function\n</code></pre> <ol> <li>there technically is no base case<ol> <li>For loop doesn\u2019t execute if branches is empty<ol> <li>that is our unofficial base case</li> </ol> </li> </ol> </li> <li>Mutating Trees</li> </ol> <p>Mutates T such that every label is doubled</p> <pre><code>#return value of this function is none\n#should actually be mutating the tree\n\ndef double_mut(t):\n    t.label *= 2\n    for b in t.branches:\n        double_mut(b)\n</code></pre> <ol> <li>Syntax Trees<ol> <li>Syntax is the branch of linguistics that studies sentence structure</li> <li>Syntax Trees aim to model the structure of languages in a way that\u2019s easy to visualized</li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2018%20Linked%20Lists/","title":"Lecture 18 Linked Lists","text":"<ol> <li>Questions</li> <li>Lists vs Linked Lists<ol> <li>List is like a bus</li> <li>A linked list is like a train (more flexible and can expand)</li> </ol> </li> <li>Linked Lists<ol> <li>Chain of objects where each object holds a value and a reference to the next link</li> <li>Linked list ends when the final reference is empty</li> </ol> </li> <li>Linked Lists Class<ol> <li>L = Link(1, Link(2, Link(3)))</li> </ol> </li> <li>Mutating Linked Lists<ol> <li>Attribute assignments can change first and rest attributes of a Link</li> <li>Using assignment statements to mutate a linked list</li> </ol> </li> <li>There can be infinite lists<ol> <li>Setting the sublist as the linked list itself</li> <li>cyclic linked lists link back on themselves</li> </ol> </li> <li>Nested Linked Lists<ol> <li>first can also be a linked list</li> </ol> </li> <li>Iteration with Linked Lists<ol> <li>Linked lists are recursive data types and therefore lead to recursive implementations<ol> <li>Using while loops<ol> <li>Doing something with the first element: l.first</li> <li>Shift the pointer to the next node: l = l.rest</li> <li>While condition: l is not Link.empty</li> </ol> </li> </ol> </li> </ol> </li> <li>Implementing Functions</li> </ol> <pre><code>def range_link(start, end)\n    \"\"\"\n    Making a function that returns a link containing consecutive integers from start to end\n    not including end\n    similar to how range works\n    \"\"\"\n    if start == end:\n        return link.empty\n    else:\n        return link(start, range_link(start+1, end))\n\ndef map_link(f, ll):\n    \"\"\"\n    Returning a link that contains f(x) for each x in link ll\n    \"\"\"\n    if ll.rest is Link.empty:\n        return link.empty\n    else:\n        return link(f(ll.first), map_link(f, ll.rest))\n\ndef filter_link(f, ll):\n    \"\"\"\n    Return a link that contains only the elements x of link ll\n    for which f(x) is a true value\n    \"\"\"\n    if ll.rest is Link.empty:\n        return Link.empty\n    elif f(ll.first):\n        return Link(ll.first, filter_link(f, ll.rest))\n    else:\n        return filter_link(f, ll.rest)\n</code></pre> <ol> <li>Linked Lists Operations<ol> <li>Insert<ol> <li>Linked lists require more space but provide faster insertion</li> </ol> </li> <li>Delete<ol> <li>No matter which node you want to delete, it takes one step:</li> <li>Point the rest of the node before the one to delete the one after</li> </ol> </li> <li>Access<ol> <li>I need to iterate through all the previous nodes using .rest</li> </ol> </li> </ol> </li> <li>Comparing Operations<ol> <li>Lists<ol> <li>insert: linear</li> <li>append: constant, sometimes linear (depends on memory allocated)</li> <li>delete: linear</li> <li>find: linear</li> <li>access: constant</li> </ol> </li> <li>Linked Lists<ol> <li>insert: constant</li> <li>delete: constant</li> <li>find: linear</li> <li>access: linear</li> </ol> </li> </ol> </li> <li>Linked List Exercises</li> </ol> <pre><code>def ordered(s, key=lambda x:x)\n    \"\"\"Is link s ordered\"\"\"\n    if s.rest is Link.empty or s is Link.empty:\n        return True\n    elif key(s.first) &gt; key(s.rest.first):\n        return False\n    else:\n        ordered(s.rest, key)\n\ndef merge(s, t):\n    \"\"\" \n    Return a sorted Link containing the eleemtns of sorted s &amp; t\n    \"\"\"\n    if s is Link.empty:\n        return s\n    elif t is Link.empty:\n        return t\n    elif s.first &lt; t.first:\n        return Link(s.first, merge(s.rest, t))\n    else:\n        return Link(t.first, merge(s, t.rest)\n\ndef merge_in_place(s, t);\n    \"\"\"Return sorted Link containing elements of sorted s &amp; t\"\"\"\n    if s is Link.empty:\n        return s\n    elif t is Link.empty:\n        return t\n    elif s.first &lt; t.first:\n        s.rest = merge_in_place(s.rest, t)\n        return s\n    else:\n        t.rest = merge_in_place(s, t.rest)\n        return t\n</code></pre> <ol> <li>Circular, Doubly Linked Lists<ol> <li>Circular linked list \u2192 list looping back on itself</li> <li>With doubly linked list<ol> <li>you can get the information about the link before and link after</li> <li>it has self.next</li> <li>also has self.prev</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2019%20Scheme%20I/","title":"Lecture 19 Scheme I","text":"<ol> <li>Questions<ol> <li>How to keep track of parentheses?</li> </ol> </li> <li>Resources<ol> <li>Page for built in functions</li> </ol> </li> <li>Scheme Expressions<ol> <li>Operators always at the front</li> <li>Primitive expression: 2, 3.3, true, +, quotient<ol> <li>Are self evaluating</li> <li>Plugging in 1 in the interpreter will just give us 1</li> </ol> </li> <li>Combinations<ol> <li>Combines things together somehow</li> <li>Things in parentheses means a combination</li> <li>(quotient 10 2)</li> </ol> </li> <li>Call expressions include an operator and 0 or more operands in parentheses<ol> <li>(quotient 10 2)</li> </ol> </li> <li>Indentation<ol> <li>Adding to the two things on the same indentations</li> </ol> </li> <li>Built in functions<ol> <li>(integer? 1.5)<ol> <li> </li> </ol> </li> </ol> </li> <li>Built in boolean procedures<ol> <li>(&lt; 4 5)<ol> <li> </li> </ol> </li> <li>Usually something with a question mark will return a boolean</li> <li>The only falsy value is #f, everything else is truthy<ol> <li>0 is truthy in scheme</li> </ol> </li> </ol> </li> </ol> </li> <li>Special Forms<ol> <li>A combination that is not a call expression is a special form</li> <li>You just kinda have to learn them</li> <li>if expression: (if  <ol> <li>if  <li>Binding symboles: (define  ) <li>New procedures: (define ( ) ) <li>Evaluation order<ol> <li>Evaluate the predicate expression</li> <li>Evaluate either the consequent of alternative</li> </ol> </li> <li>Scheme Interpreters<ol> <li>Similar to how python short circuits</li> <li>(and 1 2 3 4 5)<ol> <li>5</li> </ol> </li> <li>Don\u2019t need to wrap strings in quotes, only one at the beginning<ol> <li>print \u2018big</li> </ol> </li> <li>use () to call a function<ol> <li>Calling a Function x</li> <li>x vs (x)</li> </ol> </li> </ol> </li> <li>Lambda Expressions<ol> <li>Evaluates to anonymous procedures</li> <li>(lambda () ) <li>((define (f) 3))<ol> <li>errors because we can\u2019t call the string of f</li> </ol> </li> <li>((lambda () 3))<ol> <li>3</li> <li>this is ok</li> </ol> </li> <li>More special forms<ol> <li>We either have to evaluate the function that we created or use a lambda for helper functions</li> <li>Cond &amp; Begin<ol> <li>Cond special form that behaves like if-elif-else statements in Python</li> <li>The begin special form combines multiple expressions into one expression</li> </ol> </li> <li>Let Expressions<ol> <li>binds symbols to values temporarily, just for one expression</li> </ol> </li> </ol> </li> <li>Lists<ol> <li>Scheme Lists<ol> <li>Everything in scheme list is a linked list</li> <li>cons: two argument procedure that creates a linked list</li> <li>car: procudure that returns the first element of a list</li> <li>cds: procedure that return sth rest of a list</li> <li>nil: the empty list</li> <li>Written in parentheses with elements separated by spaces</li> </ol> </li> <li>If we create a list in Scheme, it makes a linked list<ol> <li>doesn\u2019t evaluate nested, will include the operators</li> <li>will talk more about in interpreter lecture</li> </ol> </li> </ol> </li> <li>Symbolic Programming</li> <li>List Processing</li> <li>Example: Even Subsets<ol> <li>We use a lot of recursion \u2190 No iteration</li> <li>We want the subsets that have an even sum</li> <li>Recursive approach: even subsets of s include:<ol> <li>all the even subsets of the rest of s</li> <li>the first element of s followed by an (even/odd) subset of the rest</li> <li>just the first element of s if it is even 12.</li> </ol> </li> </ol> </li>"},{"location":"su23CS61A/Lecture%2019%20Scheme%20I/#t","title":"t","text":""},{"location":"su23CS61A/Lecture%2019%20Scheme%20I/#t_1","title":"t","text":""},{"location":"su23CS61A/Lecture%202%20Functions/","title":"Lecture 2 Functions","text":"<ol> <li>Questions<ol> <li>1.2.6 Could you go over the expression tree for the print statement?</li> </ol> </li> <li>Expressions<ol> <li>describes a computation and evaluates</li> <li>similar to asking your computer a question</li> <li>Example<ol> <li>1 + 2 + 3 -5</li> </ol> </li> <li>Call expressions<ol> <li>min, max, etc.</li> <li>everything can be expressed with call expressions</li> <li>Anatomy of Call expression<ol> <li>add (2, 3)<ol> <li>add - operator</li> <li>2, 3 - operand</li> </ol> </li> </ol> </li> <li>Evaluation procedure for call expressions<ol> <li>Evaluate the operator and then the operand subexpressions</li> <li>Apply the function that is the value of the operator to the arguments that re the values of the operands</li> </ol> </li> <li>Sub expression, expression inside another expression</li> </ol> </li> <li>Names, Assignment, and User-Defined Functions<ol> <li>Using def statement to define own functions</li> <li>Function allows area to be updated with the new radius value</li> </ol> </li> <li>Types of Expressions<ol> <li>Primitive expressions: 2, add, \u2018hello\u2019</li> <li>Call expressions: max(2,3)</li> <li>g, h = min, max<ol> <li>g = min</li> <li>h = max</li> </ol> </li> </ol> </li> <li>Environment Diagrams<ol> <li>visualize the interpreter\u2019s process</li> <li>Code (left): <ol> <li>Statements and expressions</li> <li>Arrows indicate evaluation order</li> </ol> </li> <li>Frames (right): <ol> <li>Each name is bound to a value</li> <li>Within a frame, a name cannot be repeated</li> </ol> </li> </ol> </li> <li>Assignment Statements<ol> <li>Execution rules<ol> <li>Evaluate all expression to the right of = from left to right</li> <li>Bind all names to the left of = to those resulting values in the current frame</li> </ol> </li> </ol> </li> </ol> </li> <li>Defining Functions<ol> <li>Assignment is a basic means of abstraction: binds names to values</li> <li>Function definition: binds names to expressions</li> <li>def statement</li> <li>Function signature indicates how many arguments a function takes</li> <li>The function body defines the computation performed when the function is applied</li> <li>Execution procedure for def statements<ol> <li>Create a function with signature</li> <li>Set the body of that function indented after the first line</li> <li>Bind  to that function in the current frame <li>Don\u2019t necessarily need to memorize all of the procedures, but be familiar with it (included on final exam sheet)</li> <li>Return values<ol> <li>returns a value to whoever calls the functions</li> <li>code that runs after it is not run</li> </ol> </li> <li>Calling User-Defined Functions<ol> <li>Procedure<ol> <li>Add a local frame, forming a new environment</li> <li>Bind the function\u2019s formal parameters to its arguments in that frame</li> <li>Execute the body of the function in that new environment</li> </ol> </li> <li>Environment diagram<ol> <li>return value not binding</li> <li>Name of frame = name of function</li> </ol> </li> <li>Looking up names in Environments<ol> <li>Every expression is evaluated in the context of an environment</li> </ol> </li> <li>An Environment is a sequence of frames</li> <li>A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found<ol> <li>start with current environment, start our way back, until we find it</li> <li>search local frame first, then global frame</li> </ol> </li> <li>Can only have one copy of a name in a frame</li> </ol> </li> <li>Summary<ol> <li>An expression is asking your computer a question 2.</li> </ol> </li>"},{"location":"su23CS61A/Lecture%2020%20Scheme%20II%2C%20Tail%20Recursion/","title":"Lecture 20 Scheme II, Tail Recursion","text":"<ol> <li>Questions</li> <li>Dynamic Scope<ol> <li>Lexical scope - The way in which names are looked up in Scheme and Python<ol> <li>Parents of a frame is the environment in which a procedure was defined</li> </ol> </li> <li>Dynamic Scope<ol> <li>The parent of a frame is the environment in which a procedure was called</li> </ol> </li> </ol> </li> <li>Tail Recursion<ol> <li>Functional Programming<ol> <li>All functions are pure functions</li> <li>No re-assignment and no mutable data types</li> <li>Name-value bindings are permanent</li> <li>Advantages<ol> <li>Value of an expression is independent of the order in which sub-expressions are evaluated</li> <li>Sub-expressions can safely be evaluated in parallel or only on demand (lazily)</li> <li>Referential transparency: value of an expression doesn\u2019t change when we substitute one of its subexpression with the value of that subexpression</li> </ol> </li> </ol> </li> <li>Recursion and Iteration in Python<ol> <li>Python recursive calls always create new active frames</li> </ol> </li> <li>Tail recursion<ol> <li>Making recursive functions more space efficient (constant space)</li> <li>Recursive functions in scheme should be tail recursive</li> <li>Factorial function<ol> <li>Saving my value in the argument</li> <li>(factorial 6 1)</li> <li>(factorial 5 6)</li> <li>(factorial 4 30)</li> <li>\u2026</li> <li>(factorial 1 720)</li> <li>720</li> </ol> </li> </ol> </li> </ol> </li> <li>Tail Calls<ol> <li>A procedure call that has not yet returned is active</li> <li>Scheme interpreter should support an unbounded number of active tail calls using only a constant amount of space</li> <li>A tail call is a call expression in a tail context:<ol> <li>last body sub-expression in a lambda expression (or procedure definition)</li> <li>Sub expression 2 and 3 in a tail context if expression</li> <li>All non-predicate sub-expressions in a tail context cond</li> <li>Last sub expression in a tail context and, or, begin, or let</li> </ol> </li> <li>Example: Length of a list<ol> <li>Call expression is not a tail call if more computation is still required in the calling procedure</li> </ol> </li> <li>Eval with Tail Call Optimization</li> </ol> </li> <li>Tail Recursion Examples<ol> <li>Every parent function needs to be tail recursive</li> <li>If we need to do more computation after we do the recursive function then it isn\u2019t tail recursive</li> </ol> </li> <li>Map and Reduce<ol> <li>Take in an iterable</li> <li>Applies on every element in iterable</li> </ol> </li> <li>Implementing Tail Call Optimization<ol> <li>Thunk - An expression wrapped in an argument-less function</li> <li>Trampolining<ol> <li>A loop that iteratively invokes thunk-returning functions</li> <li>You\u2019ll eventually get back an answer when you keep calling a function<ol> <li>A trampoline will just keep calling until you get an answer</li> </ol> </li> </ol> </li> </ol> </li> <li>Scheme Practice<ol> <li>Extra Tail Recursion Examples     1.</li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2021%20Interpreters/","title":"Lecture 21 Interpreters","text":"<ol> <li>Questions</li> <li>Programming Languages<ol> <li>High level \u2192 Assembly \u2192 Machine</li> <li>Machine languages<ol> <li>statements interpreted by the hardware itself</li> </ol> </li> <li>High-level languages<ol> <li>statements and expressions are interpreted by another program or compiled into another language</li> </ol> </li> </ol> </li> <li>Compilers<ol> <li>translate source code into machine code so that the machine code can be distributed and run repeatedly</li> <li>Interpreters<ol> <li>run source code directly without first compiling it into machine code</li> </ol> </li> <li>Understanding source code<ol> <li>parser must be written to understand that source code</li> </ol> </li> </ol> </li> <li>Parsing<ol> <li>Reading Scheme Lists<ol> <li>All call expressions in Scheme are represented by a Scheme list</li> <li>Scheme list is written as elements in parentheses</li> <li>Each element can be a combination or primitive</li> </ol> </li> <li>Parser takes in text and returns an expression that represents the text in a tree-like structure</li> <li>Lexical Analysis<ol> <li>converts input text into a list of tokens</li> <li>each token represents the smallest unit of information</li> </ol> </li> <li>Syntatic Analysis<ol> <li>identifies the hierachical structure of an expression</li> <li>symbols can be nested</li> </ol> </li> <li>Pair Abstraction<ol> <li>A pair is similar to a linked list</li> </ol> </li> <li>Generating Pairs<ol> <li>we define a function called scheme_read that will consume the input tokens for exactly one expression</li> </ol> </li> </ol> </li> <li>The Calculator Language<ol> <li>Just primitive expressions and call expressions</li> <li>Call expression is a combination that begins with operator followed by 0 or more expressions</li> <li>Expression Trees<ol> <li>When we want to use control, we follow the same evaluation procedure</li> </ol> </li> </ol> </li> <li>Evaluation<ol> <li>Computes the value of an expression, which is always a number</li> <li>In calculator, an expression is either a number or a Pair</li> <li>Language semantics<ol> <li>A number evaluates to itself</li> <li>A call expression evaluates to its arguments values combined by an operator</li> </ol> </li> </ol> </li> <li>Interactive Interpreters<ol> <li>Read-Eval-Print Loop<ol> <li>Interactive interpreters<ol> <li>Read text input from the user</li> <li>Parse the text input into an expression</li> <li>Evaluate the expression</li> <li>If any errors occur, report those errors, otherwise</li> <li>Print the value of the expression and repeat</li> </ol> </li> </ol> </li> </ol> </li> <li>Interpreting Scheme<ol> <li>The Structure of an Interpreter<ol> <li>Eval<ol> <li>Base case: primitive values</li> <li>Recursive calls: <ol> <li>eval(operator, operands)</li> <li>Apply(procedure, arguments)</li> <li>Eval(sub-expressions) of special forms</li> </ol> </li> </ol> </li> <li>Apply<ol> <li>Base cases<ol> <li>Built-in primitive procedures</li> </ol> </li> <li>Recursive Calls<ol> <li>Eval(body) of user-defined procedures</li> </ol> </li> </ol> </li> <li>Mutual recursion among both functions</li> </ol> </li> </ol> </li> <li>Special Forms<ol> <li>The scheme_eval function choose behavior based on expression form</li> <li>Logical special forms<ol> <li>logical forms may only evaluate some sub-expressions</li> </ol> </li> </ol> </li> <li>Quotation<ol> <li>Another special form</li> <li>The expression is not evaluated</li> </ol> </li> <li>Define Expressions</li> </ol>"},{"location":"su23CS61A/Lecture%2022%20Scheme%20Data%20Abstraction/","title":"Lecture 22 Scheme Data Abstraction","text":"<ol> <li>Questions</li> <li>Data Abstraction<ol> <li>Don\u2019t need to know how things are implemented</li> <li>Only need to know what its behavior is</li> <li>Group - A scheme data abstraction<ol> <li>(group first-val second-val)</li> <li>constructs a new group from 2 arguments</li> <li>Group basically groups values together</li> <li></li> </ol> </li> <li>Note: Lists are not mutable in scheme</li> <li>Vocab<ol> <li>Data Abstraction: groups compound information into units to be accessed and manipulated</li> <li>Constructor: a procedure that creates a data abstraction</li> <li>Selector: accesses and returns some information when a data abstraction is passed into it</li> <li>Documentation: information or instructions that describe how a data abstraction work</li> <li>Implementation: how something is coded behind the scenes</li> </ol> </li> </ol> </li> <li>Abstraction Barrier<ol> <li>Each layer only uses the layer below it<ol> <li>User program</li> <li>Data Abstraction</li> <li>Primitive Representation</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2023%20Regular%20Expressions/","title":"Lecture 23 Regular Expressions","text":"<ol> <li>Questions<ol> <li>When do you need to use the backslash, such as in phone number quantifier example</li> <li>Does raw strings have to be double quotes or can it be single quotes?</li> </ol> </li> <li>Regex<ol> <li>Sequence of characters that specifies a pattern, usually utilized by string searching algorithms</li> <li>Not a programming language, just a standard that is implemented</li> <li>Using regex to specify a pattern we want to find within a string</li> </ol> </li> <li>Matching exact strings<ol> <li>Most characters in RegEx will match exactly the characters as they appear in the expression</li> <li>Some characters in regex have reserved meanings<ol> <li>Have to use escape sequence to search for those characters</li> <li>expression: {abc}\\ \u2192 {abc}</li> </ol> </li> </ol> </li> <li>The Dot character<ol> <li>reserved character that will match any single character that is not a new line</li> <li>. can basically be anything</li> <li>Expression: .a.a.a</li> <li>Fully matched by: banana, aaaaaa</li> </ol> </li> <li>Custom Character Classes<ol> <li>Character classes match any of a set of characters - one instance of a character class will match exactly one character</li> <li>Expression: [ab]c[ab]c<ol> <li>Its basically, either use a or b, then c, then a or b, then c</li> <li>Only 4 characters longth with that pattern</li> </ol> </li> <li>Can use a dash to get entire groups of characters<ol> <li>Expressions: [a-z] [0-9]<ol> <li>All the characters between those numbers</li> <li>Fully matched by a0, b8, z0, g5</li> </ol> </li> </ol> </li> <li>Note: Parentheses and Brackets are different</li> <li>Note: Whitespace matters</li> </ol> </li> <li>Common Character Classes<ol> <li>Shorthands for common character classes<ol> <li>Put on cheatsheet or study guide, don\u2019t need to necessarily memorize</li> </ol> </li> <li>. matches any non-newline character</li> <li>\\d matches digits, equivalent to [0-9]</li> <li>\\w matches \u201cword characters\u201d, equivalent to [A-Za-z0-9_]</li> <li>\\s matches whitespace characters</li> <li>[^] matches any character except whatever comes after [^]</li> <li>\\D matches any non-digit character (opposite of \\d)<ol> <li>Also \\S and \\W (capital)</li> <li>can also use the not shorthand</li> </ol> </li> </ol> </li> <li>Examples:<ol> <li>[^ab]c<ol> <li>Any character that is not an \u2018a\u2019 or \u2018b\u2019 followed by a \u2018c\u2019</li> <li>Correct: cc, zc, !c</li> <li>Incorrect: ab, bc</li> </ol> </li> <li>a*b<ol> <li>b, ab, aaaaaaaab</li> </ol> </li> <li>a+b<ol> <li>ab, aaaaaaaaab</li> <li>Note: only b doesn\u2019t work, because we need at least a</li> </ol> </li> </ol> </li> <li>Quantifiers<ol> <li>allow us to specify multiple occurrences of the same character or character class</li> <li>a* zero or more occurrences of a</li> <li>a+ one or more occurrences of a</li> <li>a? zero or one occurrences of a</li> <li>a{2} two occurrences of a</li> <li>a{2,4} two, three, or four occurrences of a</li> <li>a{2,} at least 2 occurrences of a</li> </ol> </li> <li>Combining patterns<ol> <li>The pipe | operator matches either the expression on its left or its right</li> <li>Basically an or statement<ol> <li>But cannot be both</li> </ol> </li> <li>Example:<ol> <li>\\d+|Inf</li> <li>Correct: Inf, 8</li> <li>Incorrect: 8Inf</li> </ol> </li> <li>You can use parentheses to group expressions<ol> <li>(&lt;3)+<ol> <li>&lt;3, &lt;3&lt;3&lt;3</li> </ol> </li> </ol> </li> </ol> </li> <li>Anchors<ol> <li>Another unique expression</li> <li>They don\u2019t match characters-instead, they match positions in a string where an expression could land</li> <li>^ matches the beginning of a string</li> <li>$ matches the end of a string</li> <li>\\b matches a \u201cword\u201d boundary\u201d (whitespace, punctuation)</li> <li>Examples:<ol> <li>^aw+<ol> <li>Correct: aww, awwwwwwwwwww</li> <li>Incorrect: aww aww \u2190 second aww won\u2019t be highlighted only first one</li> </ol> </li> </ol> </li> </ol> </li> <li>Note: ^ has two meanings<ol> <li>[^a] \u2192 inverse (used inside character class)</li> <li>^a \u2192 start of string (used outside character class)</li> </ol> </li> <li> <p>Regular Expressions in Python</p> <ol> <li>We use the re module in Python</li> </ol> <pre><code>import re\n\nre.search(&lt;pattern&gt;, &lt;string&gt;)\n#Returns a Match object representing the first occurrence of &lt;pattern&gt; in &lt;string&gt;\n\n#usually used with bool\nbool(re.search())\n</code></pre> </li> <li> <p>Raw Strings</p> <ol> <li>Python has escape characters built in to string evaluation such as the new line character</li> <li>Regex has \\, we use raw strings without Python thinking \\ is python</li> <li>print(r\u201dhellow\\nthere!\u201d)<ol> <li> <p>hello\\nthere</p> </li> </ol> </li> <li>Use raw strings with regex</li> </ol> </li> <li>Match objects<ol> <li>Re module has methods that attempt to match a pattern to a string- if they find a match, they\u2019ll return a match object</li> <li>If they don\u2019t find a match, they\u2019ll return None (falsey)</li> <li>re.search</li> <li>re.fullmatch(, )<ol> <li>Returns a match object requiring that pattern entirely matches string</li> </ol> <li>re.match<ol> <li>String must start with pattern</li> </ol> </li> <li>Examples:<ol> <li>Our first value is the first value that matches the pattern</li> <li>mat = re.search</li> <li> <p>mat.group(0)</p> </li> <li>\u201835\u2019</li> </ol> </li> <li>Capturing groups<ol> <li>When we use parentheses to group sub-expressions, they define capture groups that we can then access individually</li> </ol> </li> <li>Other re functions<ol> <li>re.finall<ol> <li>Returns a list of all substrings within  that match , read from left to right <li>re.sub (, , )<ol> <li>pattern is replace with repl</li> </ol> <li>Center embedding<ol> <li>Context-free grammars (CFGs)     1.</li> </ol> </li>"},{"location":"su23CS61A/Lecture%2024%20SQL%20I/","title":"Lecture 24 SQL I","text":"<ol> <li>Questions</li> <li>Declarative Programming<ol> <li>You just tell it what to do, not really about how it is</li> </ol> </li> <li>Relational Databases<ol> <li>Each table is made up of columns and rows of data</li> </ol> </li> <li>Tables<ol> <li>Have rows and columns</li> <li>Columns have a name and a type of value</li> <li>Rows have values for each column</li> </ol> </li> <li>SQL Overview<ol> <li>select - either create a new table from scratch, or grab data from another table</li> <li>create table - gives a global name to a table</li> <li>Union - concatenates tables together to make bigger ones</li> <li>All statements in SQL must end with a semicolon</li> </ol> </li> <li>Select Statements<ol> <li>Select will return 0 or more rows that match our query (the computer will just do it for us)</li> <li>Return all rows of tables<ol> <li>SELECT * FROM cities</li> <li>The * means get everything (in this case, every column)</li> </ol> </li> <li>Renaming columns<ol> <li>Select latitude as lat, longitude as lon FROM cities</li> </ol> </li> <li>Manipulate the column value<ol> <li>select city, longitude * 1000 as long_lon</li> </ol> </li> </ol> </li> <li>SQL Case-sensitive?<ol> <li>Convention - capital letters from the keywords and lowercase for the rest</li> </ol> </li> <li>Optional clauses for Select<ol> <li>There are optional clauses for the select statement</li> </ol> </li> <li>First Motivation: If<ol> <li>Where keyword in SQL<ol> <li>Lets you filter out rows</li> <li>SELECT * FROM menu WHERE price &lt; 15;<ol> <li>filtering out where price is less than 15</li> </ol> </li> <li>SELECT item FROM menu WHERE price &lt; 15:<ol> <li>returns the name of items where the price is under 15</li> </ol> </li> </ol> </li> </ol> </li> <li>Second Motivation: Sorting<ol> <li>We can use the order by method</li> <li>ORDER by will let you specify the order of the rows</li> <li>When you are sorting, default is ascending</li> </ol> </li> <li>Third Motivation: smaller output<ol> <li>We might want to only see the top 3 items by price</li> <li>LIMIT clause limits the number of rows that are output</li> </ol> </li> <li>Combining it together<ol> <li>We can use WHERE, ORDER BY, and LIMIT being used by themselves</li> <li>SQL has a specific order from each keyword<ol> <li>SELECT - FROM - WHERE - ORDER BY - LIMIT</li> </ol> </li> </ol> </li> <li>SQL Joins<ol> <li>Combining Related Tables<ol> <li>Usually better to keep tables relatively simple and join them together</li> <li>Storing everything in 1 table ends up taking far more space than storing them as two smaller tables</li> </ol> </li> </ol> </li> <li>Joining Tables<ol> <li>We do complete join in CS61a<ol> <li>Every row in table 1 is matched with every row from table 2 and all the columns are kept</li> </ol> </li> <li>Joins<ol> <li>Joining two tables together 3 columns, 50 rows and another table 5 columns, 3 rows</li> <li>8 columns, 150 rows</li> </ol> </li> </ol> </li> <li>Problems with Joining<ol> <li>A lot of rows that we create are useless</li> <li>This means that WHERE can filter out junk rows</li> </ol> </li> <li>Column Names when Joining<ol> <li>Sometimes, we have duplicate names</li> </ol> </li> <li>Aliasing<ol> <li>Basically renaming columns 2.</li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2025%20SQL%20II/","title":"Lecture 25 SQL II","text":"<ol> <li>Questions</li> <li>Review<ol> <li>Row represents each data point</li> <li>Column corresponds to a features of each data point</li> </ol> </li> <li>Querying a database<ol> <li>SELECT Query</li> </ol> </li> <li>Numerical and String Expressions<ol> <li>Expressions<ol> <li>Don\u2019t necessarily have to SELECT information directly from columns in SQL</li> <li>Can use || to concatenate strings together</li> <li>Create numeric expressions that do operations on our data<ol> <li>Transforming values: ABS(), ROUND(), NOT, -</li> <li>&lt;&gt; is equivalent to !=</li> </ol> </li> <li>Selecting substrings: SUBSTR()<ol> <li>SUBSTR(city, 1, 3)<ol> <li>[1-3] Inclusive</li> </ol> </li> </ol> </li> </ol> </li> <li>Aggregate Functions<ol> <li>Allow us to compare across all the rows in a table</li> <li>MAX()</li> </ol> </li> <li>Mixing Aggregation and Single Values<ol> <li>If we include a non-aggregated column, SQL will still fill that column with a value</li> <li>SELECT city, MIN(pop_2020) FROM pop_area_2010;</li> </ol> </li> </ol> </li> <li>Grouping<ol> <li>Creating Tables from Tables<ol> <li>Grouping<ol> <li>We can divide our table into groups, then aggregate within those groups, instead of aggregating across entire table</li> <li>Using sum or average, it can just take an arbitrary song name</li> </ol> </li> <li>Grouping by expressions</li> </ol> </li> <li>Final Query Structure and Order of Operations</li> </ol> </li> </ol> <pre><code>SELECT\nFROM\nWHERE\nGROUP BY\nHAVING\nORDER BY\nLIMIT\n</code></pre> <ol> <li>Database Connections     1.</li> </ol>"},{"location":"su23CS61A/Lecture%2026%20Special%20Topics%201%20%28Compilers%20and%20CPython%20Internals%29/","title":"Lecture 26 Special Topics 1 (Compilers and CPython Internals)","text":"<ol> <li>Questions</li> <li>Review<ol> <li>Levels of Languages<ol> <li>High-level Language</li> <li>Assembly Language</li> <li>Machine Language</li> </ol> </li> <li>Programming Languages<ol> <li>Machine languages<ol> <li>fixed set of instructions invoke operations implemented by the circuitry of the CPU</li> <li>Operations refer to specific hardware memory addresses, no abstraction</li> </ol> </li> <li>High level languages<ol> <li>Abstraction</li> </ol> </li> </ol> </li> <li>Compilers<ol> <li>translate source code into machine code so that the machine code can be distributed and run repeatedly </li> </ol> </li> <li>Interpreters <ol> <li>run source code directly producing an output/value, without first compiling it into machine code</li> </ol> </li> </ol> </li> <li>Understanding Source Code<ol> <li>parser must be written to understand that source code</li> <li>parser creates an Abstract Syntax Tree (AST)<ol> <li>AST is passed through an evaluator</li> </ol> </li> </ol> </li> <li>Parsing<ol> <li>Takes in text and returns an expression that represents the text in a tree-like structure</li> <li>Lexical analysis<ol> <li>Tells us if it accept valid characters</li> <li>such as python new lines</li> <li>converts input text into a list of tokens</li> <li>Each token represents the smallest unit of information</li> </ol> </li> <li>Syntactic analysis<ol> <li>With the tokens, creating a tree for evaluating</li> <li>identifies the hierarchical structure of an expression</li> <li>Symbols can be nested</li> </ol> </li> </ol> </li> <li>BNF<ol> <li>Backaus-Naur Form is a scheme designed specifically for describing the syntax of programming languages using context-free-grammars<ol> <li>CFG can be parsed statement by statement without needing prior context</li> <li>In python, to evaluate a line, we don\u2019t really need to know the lines before it</li> </ol> </li> <li>BNF can tell us how to make the AST</li> </ol> </li> <li>AST<ol> <li>represents the hierarchical structure of formal languages</li> <li>They <ol> <li>are unambiguous</li> <li>can be annotated</li> <li>can hold additional information about code</li> <li>are typically built by the parser</li> </ol> </li> </ol> </li> <li>Parsing Python<ol> <li>How does the program know that we only used one line of code?<ol> <li>Inspect - module that has functions to get information about live objects such as classes, functions, frames, etc.</li> <li>Ast - module to help process trees of the Python abstract syntax grammar</li> </ol> </li> <li>Dangling Else (Variation)<ol> <li>What does this evaluate to?<ol> <li> <p>1 if 2 else 3 if False else 5</p> <ol> <li>1</li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> <li>Interpreted vs Compiled<ol> <li>Who\u2019s interpreting who?<ol> <li>Big snek</li> <li>Our Python is interpreted by C</li> </ol> </li> </ol> </li> <li>CPython Internals<ol> <li>runs byte code directly producing an output/value but first compiles source code into byte code</li> <li>Compiled AST into byte code, then interpret Python</li> </ol> </li> <li>Generating Byte Code<ol> <li>Dis module<ol> <li>disassembling python code in Python bytecode</li> <li>Byte code compiler can automatically multiply before assigning value to variable</li> </ol> </li> </ol> </li> <li>Stacks<ol> <li>Stack - data strcuture for storing and retrieving values. Can only retrieve the most recently added item<ol> <li>Push - adds an item to the top</li> <li>Pop - removes an item at the top and returns it</li> <li>Peek - looks at the item at the top without removing it</li> </ol> </li> <li>Stack Machine<ol> <li>a processor or virtual machine that computes by modifying values in a stack</li> <li>Operator - combines the top two values in the stack and then pushes the result 3.</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2027%20Special%20Topics%20II%20%28Intro%20to%20Bioinformatics%29/","title":"Lecture 27 Special Topics II (Intro to Bioinformatics)","text":"<ol> <li>Questions</li> <li>Differences between different fields<ol> <li>Biomedical engineering<ol> <li>Treating diseases directly</li> </ol> </li> <li>Bioinformatics<ol> <li>More interdisciplinary</li> <li>Uses data to solve biology</li> </ol> </li> <li>Computational biology<ol> <li>using cs, math to understand biology</li> </ol> </li> <li>Biotechnology<ol> <li>using biology as technology</li> </ol> </li> </ol> </li> <li>Bioinformatics<ol> <li>Cross section between stats, cs, biology</li> <li>Fields in bioinformatics<ol> <li>Translational bioinformatics - techniques for transforming biomedical data to support health</li> <li>Public Health Informatics - development of methodologies for supporting public health needs</li> </ol> </li> </ol> </li> <li>Genome<ol> <li>C-Value Paradox: genome size fails to correlate well with apparent complexity</li> <li>Onions have more base pairs than humans</li> <li>Human genome project<ol> <li>Launched in 1990, completed in 2003</li> </ol> </li> <li>Bioinformatics: Genomic Analysis<ol> <li>Similarities in sequences: analyze traits and see how they translate to similar traits</li> <li>Differences: see how they translate to different traits</li> </ol> </li> <li>Conduct a Study<ol> <li>Is this base difference significant for disease?<ol> <li>Take two groups, one health, one has disease</li> </ol> </li> <li>Sickle Cell disease<ol> <li>Found out that one genetic base would lead to sickle cell disease</li> </ol> </li> </ol> </li> <li>Applications to Neuroscience<ol> <li>We can use genome from artic ground squirrels for seeing how to defend against stroke</li> </ol> </li> <li>Genomic Analysis for Cancer Treatment and Diagnosis<ol> <li>compare genome to health genome model and compare to other people who have cancer</li> <li>pinpoint mutations</li> </ol> </li> <li>Sequence Alignment<ol> <li>sequence alignment - way to arranging the dna sequences to identify regions of similarity </li> </ol> </li> <li>Global and Local alignment<ol> <li>Global approach compares one who sequence with other entire sequences</li> <li>Local alignment uses a subset of a sequence and attempts to align it to subset of other sequences</li> </ol> </li> <li>BLAST: Basic Local Alignment Search Tool<ol> <li>Uses a seed and extend algorithm</li> <li>its heuristic, just trial and error</li> <li>BLAST sacrifices accuracy for time, fast but not super accurate</li> </ol> </li> <li>Understanding Evolution<ol> <li>phylogenic trees allow us to visualize evolution</li> </ol> </li> </ol> </li> <li>Public Health Informatics<ol> <li>captures, manages, and analyzes information to improve population-level health outcomes</li> <li>Lead poisoning research project - can use data to prevent lead poisoning by zip codes</li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2028%20Special%20Topics%20III%20%28Python%20Pickling%29/","title":"Lecture 28 Special Topics III (Python Pickling)","text":"<ol> <li>Questions</li> <li>What is hackable?<ol> <li>Everything</li> <li>Security is important for physical safety</li> </ol> </li> <li>Security Principles<ol> <li>Know your threat model and what resources they have</li> <li>Common Assumptions for attackers<ol> <li>has the resources required to mount the attack</li> <li>can get lucky</li> </ol> </li> <li>Trusted Computing Base<ol> <li>The components of a system that the security relies upon</li> <li>generally make it smaller</li> <li>KISS principle: Keep it simple, stupid</li> </ol> </li> <li>Consider Human Factors<ol> <li>if a security system is unusable, it will be unused</li> <li>C and C++ is not memory safe</li> </ol> </li> <li>Security is Economics<ol> <li>Cost/Benefit analysis, defense should be proportional to attack</li> <li>More security costs more</li> <li>$10 lock on $1 item</li> </ol> </li> <li>Detect if you can\u2019t prevent<ol> <li>deterrence: stop attack before it happens</li> <li>prevention: stop attack as it happens</li> <li>detection: learn there was an attack afterwards</li> <li>response: do something about the attack<ol> <li>mitigation and recovery<ol> <li>have resources like emergency food supply</li> <li>offsite backups</li> </ol> </li> </ol> </li> </ol> </li> <li>Defense in Depth<ol> <li>multiple types of defenses should be layers together</li> </ol> </li> <li>Least privilege<ol> <li>consider what permissions a program needs to do its job correctly</li> </ol> </li> <li>Separation of Responsibility<ol> <li>considering requiring multiple parties to work together to exercise it</li> </ol> </li> <li>Exercise Complete Mediation<ol> <li>ensure that every access point is monitored and protected</li> </ol> </li> <li>The time-of-check to time-of-use</li> <li>Shannon Maxim<ol> <li>the enemy knows the system</li> </ol> </li> <li>Using fail-safe defaults<ol> <li>balancing security with usability</li> </ol> </li> <li>Design in security from the start<ol> <li>start with security when you start</li> </ol> </li> </ol> </li> <li>What is a system call?<ol> <li>Languages and memory<ol> <li>Pieces of information are stored at an address within a computer memory</li> </ol> </li> <li>User vs Administrator<ol> <li>only admin can access the \u201cvital organs\u201d of your computer</li> </ol> </li> </ol> </li> <li>Serialization<ol> <li>Pickling is the process where a Python object hierarchy is converted into a byte stream</li> <li>byte stream store state of object</li> <li>you want to save your program state</li> <li>reduce method<ol> <li>intended to reconstruct objects</li> </ol> </li> <li>unpacking and repacking in python</li> <li>Vulnerabilities in pickle<ol> <li>attack provides malicious code to be deserialized</li> </ol> </li> <li>Detection and Defenses: Serialization<ol> <li>can an attacker ever provide input to these functions</li> <li>don\u2019t unpickle untrusted data</li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%2029%20Final%20Review/","title":"Lecture 29 Final Review","text":"<ol> <li>Questions</li> <li>Tree problem<ol> <li>return 1 + sum([f(b, a.label) for b in a.branches])</li> <li>return sum([f(b, x) for b in a.branches])</li> <li>return f(t, t.label-1)</li> </ol> </li> <li>FA19 MT2 Q8 Their Mascot is a Tree? 4.</li> </ol>"},{"location":"su23CS61A/Lecture%203%20Control/","title":"Lecture 3 Control","text":"<ol> <li>Question<ol> <li>In what case is the parent not global?</li> <li>What is the difference between a statement and an expression?</li> </ol> </li> <li> <p>None Value</p> <ol> <li>Print doesn\u2019t include quotes in string</li> </ol> <pre><code>print(print(1), print(2))\n\n'''\nEvaluates to:\n1\n2\nNone None\n'''\n</code></pre> <ol> <li>A function that does not explicitly return a value will return None<ol> <li>None represents nothing in Python</li> <li>interpreter will not display None as the value of an expression</li> <li>\u201cprint\u201d will display None</li> </ol> </li> <li>Pure Functions &amp; Non-Pure Functions</li> <li>Pure functions<ol> <li>just return values</li> </ol> </li> <li>Non-Pure Functions<ol> <li>have side effects</li> <li>Print is a non-pure function<ol> <li>Python displays the output \u201c-2\u201d</li> </ol> </li> <li>Nested Expressions with Print<ol> <li>prints 1 and 2 as a side effect</li> <li>passes in None, into the outside print statement</li> <li>Print will separate things in commas with a space</li> </ol> </li> </ol> </li> <li>Multiple Environments</li> <li>Life cycle of a User-Define Function<ol> <li>Def statement<ol> <li>Name, formal parameter, body, return expression</li> <li>What happens<ol> <li>A new function is created</li> <li>name bound to that function in the current frame</li> </ol> </li> </ol> </li> <li>Call expression<ol> <li>operator, function, operand</li> <li>What happens<ol> <li>Operator and operands evaluated</li> <li>Function called on arguments </li> </ol> </li> </ol> </li> <li>Calling/Applying a Function<ol> <li>A new frame is created</li> <li>Parameters bound to arguments</li> <li>Body is executed in that new environment</li> </ol> </li> </ol> </li> <li>Multiple Environments in One Diagram<ol> <li>Green arrow: code that was previously evaluated</li> <li>Red arrow: next line that will be executed</li> <li>An environment is a sequence of frames<ol> <li>global frame alone</li> <li>local, then global frame</li> <li>Every expression is evaluated in the context of an environment</li> </ol> </li> <li>square is defined in the global frame, so its parent is in the global frame</li> </ol> </li> <li>Names have different meanings in Different Environments<ol> <li>A call expression and the body of the function being called are evaluated in different environments</li> </ol> </li> <li>Misc Python Features</li> <li>Can use call expressions as operators<ol> <li>from operator import mul, add, </li> </ol> </li> <li>Multiple return values<ol> <li>return x, y</li> <li>quotient, remainder = divide_exact(2023, 10)</li> <li>Doctest<ol> <li>an example case in the docstring showing how program works</li> </ol> </li> </ol> </li> <li>Default arguments<ol> <li>def divide_exact(n, d=10)<ol> <li>you are able to only pass in one argument, d will equal 10</li> <li>you are able to override by putting in 2 arguments</li> </ol> </li> </ol> </li> <li>Conditional Statements</li> <li>Statement<ol> <li>executed by the interpreter to perform an action</li> </ol> </li> <li>Compound statements<ol> <li>The first header determines a statement\u2019s type</li> <li>header of a clause \u201ccontrols\u201d the suit that follows</li> </ol> </li> <li>Execution rule<ol> <li>execute the first statement</li> <li>unless otherwise directed, execute the rest</li> </ol> </li> <li>Execution rule for conditional statements<ol> <li>evaluate the header\u2019s expression</li> <li>If it is a true value, execute the suite and skip the remaining clauses</li> </ol> </li> <li>Boolean Contexts<ol> <li>False values: False, 0, \u2018 \u2019, None</li> <li>True values: Anything else (True)</li> </ol> </li> <li>One suite per conditional statement<ol> <li>if, elif, else is all part of one conditional statement</li> </ol> </li> <li>Control Expressions</li> <li>Evaluate the expression \u201cleft\u201d and \u201cright<ol> <li>evaluate the subexpression left</li> <li>If it evaluates to a false-y value, then the expression evaluates to <ol> <li>greedy, it was everything to be true</li> </ol> <li>Otherwise, the expression evaluates to  <li>Examples<ol> <li>True and 5 \u2192 5</li> </ol> </li> <li>Evaluate left or right<ol> <li>Evaluate the subexpression  <li>If it evaluates to a truth value, v, the expression evaluates to v<ol> <li>Returns the first falsey value, or the last truthy value</li> </ol> </li> <li>Otherwise, the expression evaluates to  <li>Evaluates not expression<ol> <li>Evaluate the subexpression</li> <li>If it evaluates to a truth-y value, the expression evaluates to False</li> <li>Otherwise, the expression evaluates to True</li> <li>Examples<ol> <li>not True \u2192 False</li> <li>not (None or 0) \u2192 True</li> </ol> </li> </ol> </li> <li>Iteration</li> <li>While statements<ol> <li>Evaluate the header\u2019s expression</li> <li>If it is a true value, execute the whole suite, then return to step 1</li> </ol> </li> <li>Summary</li> <li>Pure and non pure functions<ol> <li>print displays a value as a side effect</li> </ol> </li> <li>Multiple environments can exist in a diagram</li> <li>Fllordiv, truediv, and mod are used in a boolean context</li> <li>using while statements for iteration</li>"},{"location":"su23CS61A/Lecture%204%20Higher-Order%20Functions/","title":"Lecture 4 Higher-Order Functions","text":"<ol> <li>Questions<ol> <li>When you draw an environment diagram, is the parent function when you call the function or when you define the function?</li> </ol> </li> <li>Example: Prime Factorization (Review)<ol> <li>Each positive integer n has a set of primate factors: primes whos product is n</li> <li>A possible way to solve<ol> <li>Keep dividing by smallest factor until reach 1</li> </ol> </li> <li>Using functions helps keep code readable</li> </ol> </li> <li>Example: Iteration (Review)<ol> <li>The Fibonacci Sequence<ol> <li>Multi-line assignment<ol> <li>Calculate each value on the right side</li> <li>Apply values to left side</li> </ol> </li> </ol> </li> </ol> </li> <li>Control and Call Expressions<ol> <li>Boolean Contexts<ol> <li>What is the boolean value of an expression?</li> <li>We only care if it is truthy or falsey</li> <li>Examples: x&lt;0, x==0</li> </ol> </li> <li>If Statements and Call Expressions<ol> <li>Execution rule for Conditional Statements<ol> <li>Evaluate header\u2019s expression</li> <li>If it is a true value, execute the suite and skip remaining clauses</li> </ol> </li> <li>Trying to recreate if function<ol> <li>if(\u2019header expression\u2019, \u2018if suite\u2019, \u2018else suite\u2019)</li> <li>Evaluation Rule for Call Expression<ol> <li>Evaluate operator and operand subexpressions<ol> <li>Code errors, because program tries to evaluate parameter n//d</li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> <li>Higher-Order Functions<ol> <li>Generalizing Over Computational Processes<ol> <li>Common structure among functions may be a computational process, rather than a number</li> <li>Generalizable Function<ol> <li>Can have a general function that does summation</li> <li>Use a term function to do an operation on k</li> </ol> </li> </ol> </li> </ol> </li> <li>Types of Higher-Order Functions<ol> <li>Environments Enable Higher-Order Functions<ol> <li>Higher-order functions<ol> <li>A function that takes a function as an argument value</li> <li>A function that returns a function as a return value</li> </ol> </li> <li>first class<ol> <li>Functions are values in our programming language</li> </ol> </li> </ol> </li> <li>Names can be bound to Functional Arguments<ol> <li>Applying a user-defined function<ol> <li>Create new frame</li> <li>bind formal parameters to arguments</li> <li>Execute the body</li> </ol> </li> </ol> </li> </ol> </li> <li>Functions as Return Values<ol> <li>Can return a function to generalize</li> <li>Locally Defined Functions<ol> <li>Functions defined within other function bodies are bound to names in a local frame</li> <li>Can refer to names in the enclosing function</li> </ol> </li> <li>Environment Diagrams for Nested Def Statements<ol> <li>Look at parent function before global</li> <li>Every user-defined function has a parent frame (often global)</li> <li>Parent of a frame is the parent of the function called</li> </ol> </li> <li>Call Expressions as Operator Expressions<ol> <li>make_adder(1)(2)<ol> <li>make_adder(1) is actually the operator<ol> <li>expression evaluates to a function</li> </ol> </li> <li>(2) is the operand</li> </ol> </li> </ol> </li> </ol> </li> <li>How to Draw an Environment Diagram<ol> <li>When a function is defined<ol> <li>Its parent is the current frame</li> <li>Bind name to the function value in the current frame</li> </ol> </li> <li>When a function is called<ol> <li>Add a local frame, titled with the  of the function being called <li>Copy the parent of the function to the local frame<ol> <li>based on the function definition</li> </ol> </li> <li>Bind the formal parameters to the arguments in the local frame</li> <li>Execute the body of the function in the environment that starts with the local frame</li> <li>Local Names<ol> <li>Local Names are not Visible to Other (Non-Nested) Functions<ol> <li>function g is defined in global frame<ol> <li>cannot access function f\u2019s frame</li> </ol> </li> </ol> </li> </ol> </li> <li>Function Composition</li> <li> <p>Lambda Expressions</p> <ol> <li>Another way to make a function</li> </ol> <pre><code>lambda x: x**2\n\nsquare = lambda x: x**2\n</code></pre> <ol> <li>square = x*x (expression that evaluates to a number)</li> <li>square = lambda x: x*x (also an expression: evaluates to a function)<ol> <li>def vs lambda statement<ol> <li>def statement doesn\u2019t return anything</li> <li>lambda returns a function value</li> </ol> </li> </ol> </li> <li>Syntax<ol> <li>lambda - Function</li> <li>x - with formal parameter x</li> <li>xx - returns the value of \u201cxx\u201d</li> </ol> </li> <li>Lambda expressions cannot contain statements at all</li> <li>Useful for inputs into other functions<ol> <li>faster way than def to make functions</li> </ol> </li> <li>Lambda Expressions vs def statements</li> <li>Both create a function with same domain, range, behavior</li> <li>Both bind function tothe name square</li> <li>Only the def statement gives the function an intrinsic name<ol> <li>shows up in environment diagrams, but doesn\u2019t affect execution</li> <li>Put line number for lambda, as there can be different lambda functions</li> <li>Def functions don\u2019t need line number because there can only be one name of that</li> </ol> </li> <li>Higher Order functions with Lambdas</li> <li>Lambdas can return another lambda</li> <li>Summary</li> <li>Functional abstraction<ol> <li>use logic before</li> </ol> </li> <li>Well defined functions can help redundancy in our code</li> <li>high-order functions \u2192 input/output functions</li> <li>Functions can be nested within other functions</li> <li>Control structures have different evaluation than functions</li> <li>Lambda expressions are a quick way to define simple functions within a single line</li> </ol> </li>"},{"location":"su23CS61A/Lecture%205%20Environments/","title":"Lecture 5 Environments","text":"<ol> <li>Questions<ol> <li>f2 lambda function being assigned to a parent</li> </ol> </li> <li>Environment Diagrams<ol> <li>Environment Diagrams visualize the interpreter\u2019s process</li> <li>Code on left<ol> <li>statements and expressions</li> </ol> </li> <li>Frames on right<ol> <li>Each name is bound to a value</li> <li>Names cannot be repeated in a frame</li> </ol> </li> <li>Why use environment diagrams<ol> <li>help us understand why the programs work the way they do<ol> <li>Predict how a program will behave</li> </ol> </li> </ol> </li> <li>What we have seen so far<ol> <li>Assignment Statements</li> <li>Def Statements</li> <li>Call Expressions</li> </ol> </li> <li>Assignment Statements<ol> <li>Evaluation rules<ol> <li>Evaluate all expressions to the right</li> <li>Bind all values to the left names</li> </ol> </li> </ol> </li> <li>Calling User-Defined Functions<ol> <li>Procedure<ol> <li>Add a local frame</li> <li>Bind function\u2019s formal parameters to its arguments in that frame</li> <li>Execute the body of the function in that new environment</li> </ol> </li> <li>No new frame for built-in functions</li> <li>Function\u2019s signature has all the information needed to create a local frame</li> </ol> </li> <li>Frames<ol> <li>keeps track of variable to value bindings</li> <li>global frame is default starting frame</li> <li>every call expression has a corresponding frame</li> <li>Parent of a function is the frame in which is was defined not called<ol> <li>important for variable lookup</li> </ol> </li> </ol> </li> <li>How to Draw an Environment Diagram<ol> <li>When a function is defined<ol> <li>Create a function value: func  () [parent=] <li>Its parent is the current frame, where function is defined</li> <li>When a function is called<ol> <li>Add a local frame</li> <li>Copy the parent over</li> <li>Bind the formal parameters to the arguments</li> <li>Execute the body of the function starting with local frame</li> </ol> </li> <li>Example<ol> <li>You can override a function</li> </ol> </li> <li>Evaluation Order<ol> <li>Evaluate operator, operands, apply operator to operands</li> </ol> </li> <li>Lambda Expressions<ol> <li>square = lambda x: x*x<ol> <li>lambda expression evaluates to a function</li> <li>Must be a single expression (no while loops)</li> </ol> </li> <li>Using line numbers to identify lambda functions<ol> <li>We only know of lambda\u2019s existence at f2, so its parent is f2</li> </ol> </li> </ol> </li> <li>Environments Enable Higher-Order Functions<ol> <li>Revisiting Evaluation Order<ol> <li>Higher order functions have the same rules<ol> <li>operator, operands, apply operator to operands</li> </ol> </li> </ol> </li> </ol> </li> <li>Currying<ol> <li>Function Currying<ol> <li>Break apart a function that takes in multiple arguments, into nested functions that takes in arguments separately</li> <li>making a new higher-order function</li> </ol> </li> <li>Can make it easier to think about one argument at a time</li> </ol> </li> <li>Summary<ol> <li>Environment diagrams to visualize and understand programming<ol> <li>Diagramming follow the evluation procedure for Python</li> <li>Think deeply about how the code we write actually works</li> </ol> </li> <li>Lambda expressions<ol> <li>Similar to user-defined functions but anonymous</li> <li>Simple and can be created for one-time use or stored by assigning as an input to return a function as an output</li> </ol> </li> <li>Currying, to make a HOF</li> </ol> </li>"},{"location":"su23CS61A/Lecture%206%20Functional%20Abstraction/","title":"Lecture 6 Functional Abstraction","text":"<ol> <li>Questions<ol> <li>slide 8, intrinsic name square question</li> <li>how to know what is a runtime error vs syntax error</li> </ol> </li> <li> <p>Decorators</p> <pre><code>@trace\ndef square(x):\n    return x*x\n\n\"\"\"\nDefining trace ourself\n\"\"\"\ndef trace1(fn):\n    fn = &lt;function with 1 arg&gt;\n    def traced(x):\n        print(\"Calling\", fn, \"on argument\", x)\n        return fn(x)\n    return traced\n</code></pre> <ol> <li>Writing @trace<ol> <li>Breaking down every function call</li> <li>Telling us the input and output</li> <li>Each time we call a function, tells us what we are calling the function on</li> <li>Way to transform a function into another function</li> <li>Decorator has to take in a function and return a function<ol> <li>Overrides the current function</li> <li>printing value first, then applying the function</li> </ol> </li> </ol> </li> <li>Return</li> <li>Return Statements<ol> <li>completes the evaluation of a call expression and provides it value</li> <li>switch back to previous environment, f(x) now has a value</li> <li>Only one return statement is ever executed while executing body of function</li> </ol> </li> <li>Abstraction<ol> <li>Square has the intrinsic name sqare (not needed)</li> <li>Names don\u2019t matter for correctness, but matter a lot for composition<ol> <li>best documented in docstring</li> <li>Function names typically convey their affect, behavior, value returned</li> </ol> </li> </ol> </li> <li>Which Values Deserve a Name<ol> <li>reasons to add a new name<ol> <li>repeated compound expression</li> <li>Meaningful parts of complex expressions</li> </ol> </li> </ol> </li> <li>Errors and Tracebacks</li> <li>Syntax Errors<ol> <li>Detected by the Python interpreter before program executes</li> <li>Rules about form, parentheses</li> </ol> </li> <li>Runtime Errors<ol> <li>Detected while running</li> </ol> </li> <li>Logic and Behavior Errors<ol> <li>Not detected by Python interpreter</li> <li>Program doesn\u2019t crash, but gives wrong output</li> <li>This is why we use tests</li> </ol> </li> <li>Common Bugs from Students<ol> <li>NameError<ol> <li>spelling</li> </ol> </li> <li>SyntaxError<ol> <li>Missing parenthesis</li> </ol> </li> <li>Logic and Behavior Errors<ol> <li>= vs ==</li> <li>Off by 1 errors</li> </ol> </li> <li>IndentationError</li> <li>Type Error<ol> <li>invalid types for an operator</li> <li>using non-function objects in a function call</li> <li>passing incorrect number of arguments to a function</li> </ol> </li> <li>IndexError<ol> <li>Index sequence with a # that exceeds size of sequence</li> </ol> </li> </ol> </li> <li>Debugging</li> <li>To run the doctest above</li> <li>python3 -m doctest .py<ol> <li>nothing is displayed when doctest passed</li> </ol> <li>You should test edge cases</li> <li>When running debug<ol> <li>put a variable debug and you can toggle prints when debugging</li> </ol> </li> <li>assert<ol> <li>assert isinstance(x, int), \u201cthe input of x has to be an int\u201d</li> </ol> </li> <li>Use print(\u2019DEBUG:\u2019) for okpy</li> <li>Implementing Functions</li> <li>Write about what you know about the problem</li> <li>Read the description</li> <li>Look at the examples</li> <li>Read the template<ol> <li>you may be able to change your own solution into the template 2.</li> </ol> </li>"},{"location":"su23CS61A/Lecture%207%20Recursion/","title":"Lecture 7 Recursion","text":"<ol> <li>Question<ol> <li>Going over how the Luhn Sum function works</li> <li>sum_digits_rec, still unsure about how it works</li> </ol> </li> <li>Analogy - Place in Line<ol> <li>Ask the person in front, how many people are in front of you</li> </ol> </li> <li>Recursive Functions<ol> <li>A function is called recursive if the body of that function calls itself, either directly or indirectly</li> <li>May require applying that function</li> </ol> </li> <li>Recursive Call Structure<ol> <li>Base case(s)<ol> <li>simplest instance of the problem can be solved without much work</li> <li>the trueism - no other work needed</li> <li>The first person knows their first in line</li> </ol> </li> <li>Recursive Call<ol> <li>making a call to the same function with a smaller input</li> <li>How many people in front of you?</li> </ol> </li> <li>Recombination<ol> <li>Using the result of the recursive call to solve the original problem</li> </ol> </li> </ol> </li> <li>Example: Factorial<ol> <li>To solve Factorial of 5, solve factorial of 4 * 5</li> <li>Base cases<ol> <li>think about the edges of our domain</li> </ol> </li> </ol> </li> <li>Example: Sum Digits<ol> <li>We can break the problem of summing the digits of 2023 into a smaller instance of the same problem, plus extra stuff</li> <li>Solving 2023<ol> <li>sum_digits(202) + 3</li> </ol> </li> <li>Use a split function to help<ol> <li>returns the number split into parts</li> </ol> </li> <li>Anatomy of a Recursive Function<ol> <li>Def statement header is similar to other functions</li> <li>Conditional statements check for base cases<ol> <li>base cases evaluated without recursive calls</li> </ol> </li> <li>Recursive cases are evaluated with recursive calls</li> </ol> </li> </ol> </li> <li>Recursion in Environment Diagrams<ol> <li>Every time you call a function you open a new frame</li> </ol> </li> <li>Iteration vs Recursion<ol> <li>Recursion<ol> <li>keep track of value in the arguments of the function</li> </ol> </li> </ol> </li> <li>Verifying Recursive Functions<ol> <li>The Recursive Leap of Faith<ol> <li>Is fact implemented correctly?<ol> <li>Verify the base case</li> <li>Treat fact as a functional abstraction</li> <li>Assume that fact(n-1) is correct</li> <li>Verify that fact(n) is correct</li> </ol> </li> </ol> </li> </ol> </li> <li>Mutual Recursion<ol> <li>The Luhn Algorithm<ol> <li>Rightmost digit, check digits moving left, doubling each number, sum #s &gt; 10\u2019s digits</li> <li>Take the sum of all digits</li> </ol> </li> <li>Two functions calling each other<ol> <li>Luhn sum calls luhn sum double</li> <li>Luhn sum double calls Luhn sum</li> </ol> </li> </ol> </li> <li>More Examples<ol> <li>Implementing a Function<ol> <li>Read the description</li> <li>Verify the examples and pick a simple one</li> <li>Read the template</li> <li>Annotate names with values from your chosen example</li> <li>Write code to compute the result</li> </ol> </li> <li>Remove function<ol> <li>base case: 0</li> </ol> </li> </ol> </li> <li>Converting Recursion to Iteration<ol> <li>Figure out what state must be maintained by the iterative function</li> </ol> </li> <li>Summary<ol> <li>Anatomy of Recursive functions<ol> <li>base case</li> <li>recursive case</li> <li>recombination</li> </ol> </li> <li>Mutual recursion</li> <li>Relationship between iteration and recursion</li> <li>Implementing recursive functions</li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%208%20Tree%20Recursion/","title":"Lecture 8 Tree Recursion","text":"<ol> <li>Questions<ol> <li>Can we draw a tree structure for recursion that isn\u2019t specifically tree recursion?<ol> <li>Would it just be one branch?</li> </ol> </li> </ol> </li> <li>Order of Recursive Calls<ol> <li>Pickup where you left off on the previous function</li> <li>Each cascade frame is from a different call to cascade<ol> <li>Until the return value appear, call has not been completed yet</li> </ol> </li> <li>Put the base cases first in recursive functions<ol> <li>base case - smallest case in your problem</li> </ol> </li> </ol> </li> <li>Tree Recursion<ol> <li>Tree-shaped processes arise whenever executing the body of a recursive function makes more than one recursive call</li> <li>A Tree-Recursive Process<ol> <li>The computational process of fib evolves into a tree structure</li> </ol> </li> <li>Repetition in Tree-Recursive Computation<ol> <li>Fibonacci sequence isn\u2019t super efficient as many values are calculated many times</li> </ol> </li> <li>Recursive vs Iterative<ol> <li>Recursive<ol> <li>Visually represents recursive definition</li> <li>Computation happens in many frames</li> </ol> </li> <li>Iterative<ol> <li>Easy to follow calculations</li> <li>Computation in one frame</li> </ol> </li> </ol> </li> </ol> </li> <li>Example: Counting Partitions<ol> <li>The number of partitions of a positive integer n, using parts up to size m, is the number of ways in which n can be expressed as the sum of positive integer parts up to m in increasing order</li> <li>No duplicates for combinations</li> <li>Example:<ol> <li>counter_partitions(6,4)<ol> <li>2 + 4 = 6</li> </ol> </li> </ol> </li> <li> <p>Recursive Decomposition</p> <ol> <li>finding simpler instances of the problem</li> <li>Explore two possibilities:<ol> <li>Use at least one 4</li> <li>Don\u2019t use any 4</li> </ol> </li> <li>Solve two simpler problems<ol> <li>Use at least one 4<ol> <li>After you use 4, then it becomes count_partitions(2,4)</li> </ol> </li> <li>Don\u2019t use any 4<ol> <li>If you don\u2019t use 4, then it becomes count_partitions(6,3)</li> </ol> </li> </ol> </li> </ol> <pre><code>def count_partitions(n,m):\n    if n==0:\n        return 1\n    elif n&lt;0: #failure case: overshooting\n        return 0\n    elif m==0: #failure case: there is no possible values for m when it is 0\n        return 0\n    else:\n        with_m = counter_partitions(n-m, m)\n        without_m = count_partitions(n, m-1)\n        return with_m + without_m\n</code></pre> <ol> <li>Tree recursion<ol> <li>multiple recursive calls within its body, each modeling a specific decision</li> <li>base cases may not always be apparent, and sometimes working through recursive calls can help you figure them out</li> </ol> </li> </ol> </li> </ol> </li> </ol>"},{"location":"su23CS61A/Lecture%209%20Sequences%20%26%20Containers/","title":"Lecture 9 Sequences &amp; Containers","text":"<ol> <li>Questions<ol> <li>Is a key of a dictionary an index?</li> </ol> </li> <li>Sequences<ol> <li>ordered collection of values</li> <li>different types<ol> <li>strings - \u201chello world\u201d</li> <li>lists - [1, \u201ca\u201d, 2, \u201cb\u201d]<ol> <li>can be any data type</li> </ol> </li> <li>ranges - range(0,10)<ol> <li>sequence of numbers</li> </ol> </li> </ol> </li> </ol> </li> <li>Strings<ol> <li>Strings are abstraction<ol> <li>Representing data</li> <li>Representing language</li> <li>Representing programs<ol> <li>can just put syntax into strings</li> </ol> </li> <li>Single and Double quotes are equivalent</li> </ol> </li> </ol> </li> <li> <p>Lists</p> <ol> <li>Container that holds a sequence of values of any data type</li> <li>Empty list<ol> <li>l = []</li> </ol> </li> <li>List can hold any python value, separated by commas<ol> <li>Able to hold functions as well</li> </ol> </li> <li> <p>Creating Lists</p> <ol> <li>nums = [2, 81, 16]</li> <li>We can also put call expression into our lists</li> <li>calc = [min(2,3), square(9,9)]</li> </ol> <pre><code>&gt;&gt;&gt; calc\n[2, 81]\n\n#lists will evaluate things inside\n</code></pre> </li> <li> <p>List Lengths</p> <ol> <li>\u201clen\u201d function computes the length of a list</li> </ol> </li> <li>Indexing Lists<ol> <li>Indexes start at 0</li> <li>Able to access an item by putting square brackets [] around it<ol> <li>getitem(,  <li>Negative indexing starts from back of list<ol> <li>[-1] returns the last index</li> </ol> </li> <li>Concatenation and Repetition<ol> <li>Can only concatenate a list with a list</li> <li>Multiplying *2 doubles the list and etc.</li> </ol> </li> <li>List Slicing<ol> <li>Passing 3 arguments</li> <li>list[ :  :  ]<ol> <li>does not include end index</li> </ol> <li>Reversing a list<ol> <li>Use a negative step size</li> <li>s[::1]</li> </ol> </li> <li>Nested Lists<ol> <li>Can have lists in a list</li> <li>\u201clen\u201d won\u2019t go through nested items<ol> <li>items separated by commas</li> </ol> </li> </ol> </li> <li>Box and Pointer Notation (similar to environment diagram)</li> <li>creating a copy of a list<ol> <li>c = a[:]<ol> <li>slicing creates a copy</li> <li>a new list</li> </ol> </li> </ol> </li> <li>Reversing<ol> <li>We look at the original indexes to reverse</li> <li>Starting index should be larger than ending index<ol> <li>Step size is -1, we are working backward</li> </ol> </li> </ol> </li> <li>In environment diagrams<ol> <li>Lists are represented as a row of index-labeled adjacent boxes</li> <li>each box either contains a primitive value or points to compound value</li> </ol> </li> <li>Strings as Sequences<ol> <li>Strings can also be sliced, concatenated</li> <li>classes[:5]<ol> <li>Remember that it slices up to but not including the number</li> </ol> </li> </ol> </li> <li>Containers</li> <li>Sequence is a type of container where we have elements in order</li> <li> <p>Built in operator for testing whether an element appear in a compound value</p> <ol> <li>\u201cnot in\u201d and \u201cin\u201d</li> </ol> <pre><code>&gt;&gt;&gt;digits = [1,8,2,8]\n&gt;&gt;&gt;1 in digits\nTrue\n</code></pre> </li> <li> <p>For Statements</p> <ol> <li>For statement execution procedure</li> </ol> <pre><code>for &lt;name&gt; in &lt;expression&gt;:\n    &lt;suite&gt;\n</code></pre> <ol> <li>Evaluate the header, which must yield an iterable value (a sequence) <li>For each element in that sequence, in order:<ol> <li>Bind  to that element in the current frame <li>Execute the  <li> <p>Sequence Unpacking in For Statements</p> <ol> <li></li> </ol> <pre><code>pairs = [[1,2], [2,2]]\n\nfor x, y in pairs:\n    x == y:\n        same_count += 1\n</code></pre> </li> <li> <p>Ranges</p> <ol> <li>Range function creates a sequence of consecutive integers</li> <li>range(, , )<ol> <li>Non-inclusive for end value</li> <li>inclusive for start value</li> </ol> <li>list(range(4)<ol> <li>[0,1,2,3]</li> </ol> </li> <li> <p>List Comprehensions</p> <ol> <li>Can have a for loop that can do an operation</li> </ol> <pre><code>[&lt;map exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;]\n\n[&lt;map exp&gt; for &lt;name&gt; in &lt;iter exp&gt;]\n</code></pre> <ol> <li>Combined expression that evaluates to a list using this evaluation procedure<ol> <li>Add a new frame with the current frame as its parent</li> <li>Create empty result list that is the value of the expression</li> <li>For each element in the iterable value of :<ol> <li>Bind  to that element in the new frame from step 1 <li>If  evaluates to a true value, then add the values of  to resulting list <li>Aggregation</li> <li>Build-in functions take iterable arguments and aggregate them into a value</li> <li>sum()<ol> <li>sums a list\u2019</li> </ol> </li> <li>max()<ol> <li>maximum character in a string</li> <li>maximum number in a list</li> <li>key applies the function to the items in the list</li> </ol> </li> <li>min()</li> <li>all()<ol> <li>returns whether all the numbers in the list are truthy</li> </ol> </li> <li>Dictionaries</li> <li>Limitations on Dictionaries<ol> <li>Dictionaries are collections of key-value pairs</li> <li>Dictionary keys do have two restrictions:<ol> <li>A key of a dictionary cannot be a list or a dictionary (or any mutable type)</li> </ol> </li> </ol> </li> <li>Summary</li> <li>Containers (lists and dictionaries) can store sequences of values</li> <li>List slicing creates a new list</li> <li>We can iterate over sequences using for statements<ol> <li>Can be more concise than while statements</li> </ol> </li> <li>List comprehension allows us to return a new list using values of an existing list</li> <li>Memoization makes computing more efficient</li>"}]}